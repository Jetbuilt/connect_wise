# #Connectwise Manage All Endpoints
#
# No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
#
# The version of the OpenAPI document: 2022.1
#
# Generated by: https://openapi-generator.tech
# OpenAPI Generator version: 6.2.1
#

require 'date'
require 'time'

module ConnectWise
  class CompanyMerge
    attr_accessor :to_company_id, :name, :identifier, :status, :type, :primary_address, :primary_contact, :phone, :fax, :website, :market, :territory, :revenue, :revenue_year, :number_of_employees, :sic_code, :date_acquired, :time_zone, :source_list, :user_defined_field1, :user_defined_field2, :user_defined_field3, :user_defined_field4, :user_defined_field5, :user_defined_field6, :user_defined_field7, :user_defined_field8, :user_defined_field9, :user_defined_field10, :billing_address, :billing_contact, :tax_code, :account_number, :billing_terms, :notes, :sites, :activities, :opportunities, :services, :projects, :contacts, :documents

    class EnumAttributeValidator
      attr_reader :datatype, :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        to_company_id: :toCompanyId,
        name: :name,
        identifier: :identifier,
        status: :status,
        type: :type,
        primary_address: :primaryAddress,
        primary_contact: :primaryContact,
        phone: :phone,
        fax: :fax,
        website: :website,
        market: :market,
        territory: :territory,
        revenue: :revenue,
        revenue_year: :revenueYear,
        number_of_employees: :numberOfEmployees,
        sic_code: :sicCode,
        date_acquired: :dateAcquired,
        time_zone: :timeZone,
        source_list: :sourceList,
        user_defined_field1: :userDefinedField1,
        user_defined_field2: :userDefinedField2,
        user_defined_field3: :userDefinedField3,
        user_defined_field4: :userDefinedField4,
        user_defined_field5: :userDefinedField5,
        user_defined_field6: :userDefinedField6,
        user_defined_field7: :userDefinedField7,
        user_defined_field8: :userDefinedField8,
        user_defined_field9: :userDefinedField9,
        user_defined_field10: :userDefinedField10,
        billing_address: :billingAddress,
        billing_contact: :billingContact,
        tax_code: :taxCode,
        account_number: :accountNumber,
        billing_terms: :billingTerms,
        notes: :notes,
        sites: :sites,
        activities: :activities,
        opportunities: :opportunities,
        services: :services,
        projects: :projects,
        contacts: :contacts,
        documents: :documents
      }
    end

    # Returns all the JSON keys this model knows about
    def self.acceptable_attributes
      attribute_map.values
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        to_company_id: :Integer,
        name: :String,
        identifier: :String,
        status: :String,
        type: :String,
        primary_address: :String,
        primary_contact: :String,
        phone: :String,
        fax: :String,
        website: :String,
        market: :String,
        territory: :String,
        revenue: :String,
        revenue_year: :String,
        number_of_employees: :String,
        sic_code: :String,
        date_acquired: :String,
        time_zone: :String,
        source_list: :String,
        user_defined_field1: :String,
        user_defined_field2: :String,
        user_defined_field3: :String,
        user_defined_field4: :String,
        user_defined_field5: :String,
        user_defined_field6: :String,
        user_defined_field7: :String,
        user_defined_field8: :String,
        user_defined_field9: :String,
        user_defined_field10: :String,
        billing_address: :String,
        billing_contact: :String,
        tax_code: :String,
        account_number: :String,
        billing_terms: :String,
        notes: :String,
        sites: :String,
        activities: :String,
        opportunities: :String,
        services: :String,
        projects: :String,
        contacts: :String,
        documents: :String
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new(%i[
                name
                identifier
                status
                type
                primary_address
                primary_contact
                phone
                fax
                website
                market
                territory
                revenue
                revenue_year
                number_of_employees
                sic_code
                date_acquired
                time_zone
                source_list
                user_defined_field1
                user_defined_field2
                user_defined_field3
                user_defined_field4
                user_defined_field5
                user_defined_field6
                user_defined_field7
                user_defined_field8
                user_defined_field9
                user_defined_field10
                billing_address
                billing_contact
                tax_code
                account_number
                billing_terms
                notes
                sites
                activities
                opportunities
                services
                projects
                contacts
                documents
              ])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      raise ArgumentError, 'The input argument (attributes) must be a hash in `ConnectWise::CompanyMerge` initialize method' unless attributes.is_a?(Hash)

      # check to see if the attribute exists and convert string to symbol for hash key
      attributes = attributes.each_with_object({}) do |(k, v), h|
        raise ArgumentError, "`#{k}` is not a valid attribute in `ConnectWise::CompanyMerge`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect unless self.class.attribute_map.key?(k.to_sym)

        h[k.to_sym] = v
      end

      self.to_company_id = attributes[:to_company_id] if attributes.key?(:to_company_id)

      self.name = attributes[:name] if attributes.key?(:name)

      self.identifier = attributes[:identifier] if attributes.key?(:identifier)

      self.status = attributes[:status] if attributes.key?(:status)

      self.type = attributes[:type] if attributes.key?(:type)

      self.primary_address = attributes[:primary_address] if attributes.key?(:primary_address)

      self.primary_contact = attributes[:primary_contact] if attributes.key?(:primary_contact)

      self.phone = attributes[:phone] if attributes.key?(:phone)

      self.fax = attributes[:fax] if attributes.key?(:fax)

      self.website = attributes[:website] if attributes.key?(:website)

      self.market = attributes[:market] if attributes.key?(:market)

      self.territory = attributes[:territory] if attributes.key?(:territory)

      self.revenue = attributes[:revenue] if attributes.key?(:revenue)

      self.revenue_year = attributes[:revenue_year] if attributes.key?(:revenue_year)

      self.number_of_employees = attributes[:number_of_employees] if attributes.key?(:number_of_employees)

      self.sic_code = attributes[:sic_code] if attributes.key?(:sic_code)

      self.date_acquired = attributes[:date_acquired] if attributes.key?(:date_acquired)

      self.time_zone = attributes[:time_zone] if attributes.key?(:time_zone)

      self.source_list = attributes[:source_list] if attributes.key?(:source_list)

      self.user_defined_field1 = attributes[:user_defined_field1] if attributes.key?(:user_defined_field1)

      self.user_defined_field2 = attributes[:user_defined_field2] if attributes.key?(:user_defined_field2)

      self.user_defined_field3 = attributes[:user_defined_field3] if attributes.key?(:user_defined_field3)

      self.user_defined_field4 = attributes[:user_defined_field4] if attributes.key?(:user_defined_field4)

      self.user_defined_field5 = attributes[:user_defined_field5] if attributes.key?(:user_defined_field5)

      self.user_defined_field6 = attributes[:user_defined_field6] if attributes.key?(:user_defined_field6)

      self.user_defined_field7 = attributes[:user_defined_field7] if attributes.key?(:user_defined_field7)

      self.user_defined_field8 = attributes[:user_defined_field8] if attributes.key?(:user_defined_field8)

      self.user_defined_field9 = attributes[:user_defined_field9] if attributes.key?(:user_defined_field9)

      self.user_defined_field10 = attributes[:user_defined_field10] if attributes.key?(:user_defined_field10)

      self.billing_address = attributes[:billing_address] if attributes.key?(:billing_address)

      self.billing_contact = attributes[:billing_contact] if attributes.key?(:billing_contact)

      self.tax_code = attributes[:tax_code] if attributes.key?(:tax_code)

      self.account_number = attributes[:account_number] if attributes.key?(:account_number)

      self.billing_terms = attributes[:billing_terms] if attributes.key?(:billing_terms)

      self.notes = attributes[:notes] if attributes.key?(:notes)

      self.sites = attributes[:sites] if attributes.key?(:sites)

      self.activities = attributes[:activities] if attributes.key?(:activities)

      self.opportunities = attributes[:opportunities] if attributes.key?(:opportunities)

      self.services = attributes[:services] if attributes.key?(:services)

      self.projects = attributes[:projects] if attributes.key?(:projects)

      self.contacts = attributes[:contacts] if attributes.key?(:contacts)

      return unless attributes.key?(:documents)

      self.documents = attributes[:documents]
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = []
      invalid_properties.push('invalid value for "to_company_id", to_company_id cannot be nil.') if @to_company_id.nil?

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if @to_company_id.nil?

      name_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless name_validator.valid?(@name)

      identifier_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless identifier_validator.valid?(@identifier)

      status_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless status_validator.valid?(@status)

      type_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless type_validator.valid?(@type)

      primary_address_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless primary_address_validator.valid?(@primary_address)

      primary_contact_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless primary_contact_validator.valid?(@primary_contact)

      phone_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless phone_validator.valid?(@phone)

      fax_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless fax_validator.valid?(@fax)

      website_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless website_validator.valid?(@website)

      market_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless market_validator.valid?(@market)

      territory_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless territory_validator.valid?(@territory)

      revenue_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless revenue_validator.valid?(@revenue)

      revenue_year_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless revenue_year_validator.valid?(@revenue_year)

      number_of_employees_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless number_of_employees_validator.valid?(@number_of_employees)

      sic_code_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless sic_code_validator.valid?(@sic_code)

      date_acquired_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless date_acquired_validator.valid?(@date_acquired)

      time_zone_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless time_zone_validator.valid?(@time_zone)

      source_list_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless source_list_validator.valid?(@source_list)

      user_defined_field1_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless user_defined_field1_validator.valid?(@user_defined_field1)

      user_defined_field2_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless user_defined_field2_validator.valid?(@user_defined_field2)

      user_defined_field3_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless user_defined_field3_validator.valid?(@user_defined_field3)

      user_defined_field4_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless user_defined_field4_validator.valid?(@user_defined_field4)

      user_defined_field5_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless user_defined_field5_validator.valid?(@user_defined_field5)

      user_defined_field6_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless user_defined_field6_validator.valid?(@user_defined_field6)

      user_defined_field7_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless user_defined_field7_validator.valid?(@user_defined_field7)

      user_defined_field8_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless user_defined_field8_validator.valid?(@user_defined_field8)

      user_defined_field9_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless user_defined_field9_validator.valid?(@user_defined_field9)

      user_defined_field10_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless user_defined_field10_validator.valid?(@user_defined_field10)

      billing_address_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless billing_address_validator.valid?(@billing_address)

      billing_contact_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless billing_contact_validator.valid?(@billing_contact)

      tax_code_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless tax_code_validator.valid?(@tax_code)

      account_number_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless account_number_validator.valid?(@account_number)

      billing_terms_validator = EnumAttributeValidator.new('String', %w[From To])
      return false unless billing_terms_validator.valid?(@billing_terms)

      notes_validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      return false unless notes_validator.valid?(@notes)

      sites_validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      return false unless sites_validator.valid?(@sites)

      activities_validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      return false unless activities_validator.valid?(@activities)

      opportunities_validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      return false unless opportunities_validator.valid?(@opportunities)

      services_validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      return false unless services_validator.valid?(@services)

      projects_validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      return false unless projects_validator.valid?(@projects)

      contacts_validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      return false unless contacts_validator.valid?(@contacts)

      documents_validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      return false unless documents_validator.valid?(@documents)

      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] name Object to be assigned
    def name=(name)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"name\", must be one of #{validator.allowable_values}." unless validator.valid?(name)

      @name = name
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] identifier Object to be assigned
    def identifier=(identifier)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"identifier\", must be one of #{validator.allowable_values}." unless validator.valid?(identifier)

      @identifier = identifier
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] status Object to be assigned
    def status=(status)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"status\", must be one of #{validator.allowable_values}." unless validator.valid?(status)

      @status = status
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] type Object to be assigned
    def type=(type)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"type\", must be one of #{validator.allowable_values}." unless validator.valid?(type)

      @type = type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] primary_address Object to be assigned
    def primary_address=(primary_address)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"primary_address\", must be one of #{validator.allowable_values}." unless validator.valid?(primary_address)

      @primary_address = primary_address
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] primary_contact Object to be assigned
    def primary_contact=(primary_contact)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"primary_contact\", must be one of #{validator.allowable_values}." unless validator.valid?(primary_contact)

      @primary_contact = primary_contact
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] phone Object to be assigned
    def phone=(phone)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"phone\", must be one of #{validator.allowable_values}." unless validator.valid?(phone)

      @phone = phone
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] fax Object to be assigned
    def fax=(fax)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"fax\", must be one of #{validator.allowable_values}." unless validator.valid?(fax)

      @fax = fax
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] website Object to be assigned
    def website=(website)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"website\", must be one of #{validator.allowable_values}." unless validator.valid?(website)

      @website = website
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] market Object to be assigned
    def market=(market)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"market\", must be one of #{validator.allowable_values}." unless validator.valid?(market)

      @market = market
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] territory Object to be assigned
    def territory=(territory)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"territory\", must be one of #{validator.allowable_values}." unless validator.valid?(territory)

      @territory = territory
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] revenue Object to be assigned
    def revenue=(revenue)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"revenue\", must be one of #{validator.allowable_values}." unless validator.valid?(revenue)

      @revenue = revenue
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] revenue_year Object to be assigned
    def revenue_year=(revenue_year)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"revenue_year\", must be one of #{validator.allowable_values}." unless validator.valid?(revenue_year)

      @revenue_year = revenue_year
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] number_of_employees Object to be assigned
    def number_of_employees=(number_of_employees)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"number_of_employees\", must be one of #{validator.allowable_values}." unless validator.valid?(number_of_employees)

      @number_of_employees = number_of_employees
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] sic_code Object to be assigned
    def sic_code=(sic_code)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"sic_code\", must be one of #{validator.allowable_values}." unless validator.valid?(sic_code)

      @sic_code = sic_code
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] date_acquired Object to be assigned
    def date_acquired=(date_acquired)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"date_acquired\", must be one of #{validator.allowable_values}." unless validator.valid?(date_acquired)

      @date_acquired = date_acquired
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] time_zone Object to be assigned
    def time_zone=(time_zone)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"time_zone\", must be one of #{validator.allowable_values}." unless validator.valid?(time_zone)

      @time_zone = time_zone
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] source_list Object to be assigned
    def source_list=(source_list)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"source_list\", must be one of #{validator.allowable_values}." unless validator.valid?(source_list)

      @source_list = source_list
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] user_defined_field1 Object to be assigned
    def user_defined_field1=(user_defined_field1)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"user_defined_field1\", must be one of #{validator.allowable_values}." unless validator.valid?(user_defined_field1)

      @user_defined_field1 = user_defined_field1
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] user_defined_field2 Object to be assigned
    def user_defined_field2=(user_defined_field2)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"user_defined_field2\", must be one of #{validator.allowable_values}." unless validator.valid?(user_defined_field2)

      @user_defined_field2 = user_defined_field2
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] user_defined_field3 Object to be assigned
    def user_defined_field3=(user_defined_field3)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"user_defined_field3\", must be one of #{validator.allowable_values}." unless validator.valid?(user_defined_field3)

      @user_defined_field3 = user_defined_field3
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] user_defined_field4 Object to be assigned
    def user_defined_field4=(user_defined_field4)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"user_defined_field4\", must be one of #{validator.allowable_values}." unless validator.valid?(user_defined_field4)

      @user_defined_field4 = user_defined_field4
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] user_defined_field5 Object to be assigned
    def user_defined_field5=(user_defined_field5)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"user_defined_field5\", must be one of #{validator.allowable_values}." unless validator.valid?(user_defined_field5)

      @user_defined_field5 = user_defined_field5
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] user_defined_field6 Object to be assigned
    def user_defined_field6=(user_defined_field6)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"user_defined_field6\", must be one of #{validator.allowable_values}." unless validator.valid?(user_defined_field6)

      @user_defined_field6 = user_defined_field6
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] user_defined_field7 Object to be assigned
    def user_defined_field7=(user_defined_field7)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"user_defined_field7\", must be one of #{validator.allowable_values}." unless validator.valid?(user_defined_field7)

      @user_defined_field7 = user_defined_field7
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] user_defined_field8 Object to be assigned
    def user_defined_field8=(user_defined_field8)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"user_defined_field8\", must be one of #{validator.allowable_values}." unless validator.valid?(user_defined_field8)

      @user_defined_field8 = user_defined_field8
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] user_defined_field9 Object to be assigned
    def user_defined_field9=(user_defined_field9)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"user_defined_field9\", must be one of #{validator.allowable_values}." unless validator.valid?(user_defined_field9)

      @user_defined_field9 = user_defined_field9
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] user_defined_field10 Object to be assigned
    def user_defined_field10=(user_defined_field10)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"user_defined_field10\", must be one of #{validator.allowable_values}." unless validator.valid?(user_defined_field10)

      @user_defined_field10 = user_defined_field10
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] billing_address Object to be assigned
    def billing_address=(billing_address)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"billing_address\", must be one of #{validator.allowable_values}." unless validator.valid?(billing_address)

      @billing_address = billing_address
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] billing_contact Object to be assigned
    def billing_contact=(billing_contact)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"billing_contact\", must be one of #{validator.allowable_values}." unless validator.valid?(billing_contact)

      @billing_contact = billing_contact
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] tax_code Object to be assigned
    def tax_code=(tax_code)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"tax_code\", must be one of #{validator.allowable_values}." unless validator.valid?(tax_code)

      @tax_code = tax_code
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] account_number Object to be assigned
    def account_number=(account_number)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"account_number\", must be one of #{validator.allowable_values}." unless validator.valid?(account_number)

      @account_number = account_number
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] billing_terms Object to be assigned
    def billing_terms=(billing_terms)
      validator = EnumAttributeValidator.new('String', %w[From To])
      raise ArgumentError, "invalid value for \"billing_terms\", must be one of #{validator.allowable_values}." unless validator.valid?(billing_terms)

      @billing_terms = billing_terms
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] notes Object to be assigned
    def notes=(notes)
      validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      raise ArgumentError, "invalid value for \"notes\", must be one of #{validator.allowable_values}." unless validator.valid?(notes)

      @notes = notes
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] sites Object to be assigned
    def sites=(sites)
      validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      raise ArgumentError, "invalid value for \"sites\", must be one of #{validator.allowable_values}." unless validator.valid?(sites)

      @sites = sites
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] activities Object to be assigned
    def activities=(activities)
      validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      raise ArgumentError, "invalid value for \"activities\", must be one of #{validator.allowable_values}." unless validator.valid?(activities)

      @activities = activities
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] opportunities Object to be assigned
    def opportunities=(opportunities)
      validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      raise ArgumentError, "invalid value for \"opportunities\", must be one of #{validator.allowable_values}." unless validator.valid?(opportunities)

      @opportunities = opportunities
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] services Object to be assigned
    def services=(services)
      validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      raise ArgumentError, "invalid value for \"services\", must be one of #{validator.allowable_values}." unless validator.valid?(services)

      @services = services
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] projects Object to be assigned
    def projects=(projects)
      validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      raise ArgumentError, "invalid value for \"projects\", must be one of #{validator.allowable_values}." unless validator.valid?(projects)

      @projects = projects
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] contacts Object to be assigned
    def contacts=(contacts)
      validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      raise ArgumentError, "invalid value for \"contacts\", must be one of #{validator.allowable_values}." unless validator.valid?(contacts)

      @contacts = contacts
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] documents Object to be assigned
    def documents=(documents)
      validator = EnumAttributeValidator.new('String', %w[Discard Merge])
      raise ArgumentError, "invalid value for \"documents\", must be one of #{validator.allowable_values}." unless validator.valid?(documents)

      @documents = documents
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        to_company_id == other.to_company_id &&
        name == other.name &&
        identifier == other.identifier &&
        status == other.status &&
        type == other.type &&
        primary_address == other.primary_address &&
        primary_contact == other.primary_contact &&
        phone == other.phone &&
        fax == other.fax &&
        website == other.website &&
        market == other.market &&
        territory == other.territory &&
        revenue == other.revenue &&
        revenue_year == other.revenue_year &&
        number_of_employees == other.number_of_employees &&
        sic_code == other.sic_code &&
        date_acquired == other.date_acquired &&
        time_zone == other.time_zone &&
        source_list == other.source_list &&
        user_defined_field1 == other.user_defined_field1 &&
        user_defined_field2 == other.user_defined_field2 &&
        user_defined_field3 == other.user_defined_field3 &&
        user_defined_field4 == other.user_defined_field4 &&
        user_defined_field5 == other.user_defined_field5 &&
        user_defined_field6 == other.user_defined_field6 &&
        user_defined_field7 == other.user_defined_field7 &&
        user_defined_field8 == other.user_defined_field8 &&
        user_defined_field9 == other.user_defined_field9 &&
        user_defined_field10 == other.user_defined_field10 &&
        billing_address == other.billing_address &&
        billing_contact == other.billing_contact &&
        tax_code == other.tax_code &&
        account_number == other.account_number &&
        billing_terms == other.billing_terms &&
        notes == other.notes &&
        sites == other.sites &&
        activities == other.activities &&
        opportunities == other.opportunities &&
        services == other.services &&
        projects == other.projects &&
        contacts == other.contacts &&
        documents == other.documents
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(other)
      self == other
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [to_company_id, name, identifier, status, type, primary_address, primary_contact, phone, fax, website, market, territory, revenue, revenue_year, number_of_employees, sic_code, date_acquired, time_zone, source_list, user_defined_field1, user_defined_field2, user_defined_field3, user_defined_field4, user_defined_field5, user_defined_field6, user_defined_field7, user_defined_field8, user_defined_field9, user_defined_field10, billing_address, billing_contact, tax_code, account_number, billing_terms, notes, sites, activities, opportunities, services, projects, contacts, documents].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      new.build_from_hash(attributes)
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      attributes = attributes.transform_keys(&:to_sym)
      self.class.openapi_types.each_pair do |key, type|
        if attributes[self.class.attribute_map[key]].nil? && self.class.openapi_nullable.include?(key)
          send("#{key}=", nil)
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize(::Regexp.last_match(1), v) }) if attributes[self.class.attribute_map[key]].is_a?(Array)
        elsif !attributes[self.class.attribute_map[key]].nil?
          send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = ConnectWise.const_get(type)
        klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end

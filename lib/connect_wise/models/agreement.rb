# #Connectwise Manage All Endpoints
#
# No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
#
# The version of the OpenAPI document: 2022.1
#
# Generated by: https://openapi-generator.tech
# OpenAPI Generator version: 6.2.1
#

require 'date'
require 'time'

module ConnectWise
  class Agreement
    #  Max length: 100;
    attr_accessor :name

    attr_accessor :id, :type, :company, :contact, :site, :sub_contract_company, :sub_contract_contact, :parent_agreement, :location, :department, :restrict_location_flag, :restrict_department_flag, :start_date, :end_date, :no_ending_date_flag, :opportunity, :cancelled_flag, :date_cancelled, :sla, :internal_notes, :application_units, :application_limit, :application_cycle, :application_unlimited_flag, :one_time_flag, :cover_agreement_time, :cover_agreement_product, :cover_agreement_expense, :cover_sales_tax, :carry_over_unused, :allow_overruns, :expired_days, :limit, :expire_when_zero, :charge_to_firm, :employee_comp_not_exceed, :comp_hourly_rate, :comp_limit_amount, :billing_cycle, :bill_one_time_flag, :billing_terms, :bill_to_company, :bill_to_contact, :bill_to_site, :bill_amount, :taxable, :prorate_first_bill, :bill_start_date, :tax_code, :restrict_down_payment, :prorate_flag, :invoice_description, :top_comment, :bottom_comment, :work_role, :work_type, :project_type, :invoice_template, :billable_time_invoice, :billable_expense_invoice, :billable_product_invoice, :currency, :period_type, :auto_invoice_flag, :next_invoice_date, :company_location, :agreement_status, :_info, :custom_fields

    #  Max length: 50;
    attr_accessor :customer_po

    #  Max length: 100;
    attr_accessor :reason_cancelled

    #  Max length: 20;
    attr_accessor :work_order

    #  Required On Updates;
    attr_accessor :employee_comp_rate

    #  Required On Updates;
    attr_accessor :invoicing_cycle

    #  Required On Updates;
    attr_accessor :bill_time

    #  Required On Updates;
    attr_accessor :bill_expenses

    #  Required On Updates;
    attr_accessor :bill_products

    class EnumAttributeValidator
      attr_reader :datatype, :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        name: :name,
        id: :id,
        type: :type,
        company: :company,
        contact: :contact,
        site: :site,
        sub_contract_company: :subContractCompany,
        sub_contract_contact: :subContractContact,
        parent_agreement: :parentAgreement,
        customer_po: :customerPO,
        location: :location,
        department: :department,
        restrict_location_flag: :restrictLocationFlag,
        restrict_department_flag: :restrictDepartmentFlag,
        start_date: :startDate,
        end_date: :endDate,
        no_ending_date_flag: :noEndingDateFlag,
        opportunity: :opportunity,
        cancelled_flag: :cancelledFlag,
        date_cancelled: :dateCancelled,
        reason_cancelled: :reasonCancelled,
        sla: :sla,
        work_order: :workOrder,
        internal_notes: :internalNotes,
        application_units: :applicationUnits,
        application_limit: :applicationLimit,
        application_cycle: :applicationCycle,
        application_unlimited_flag: :applicationUnlimitedFlag,
        one_time_flag: :oneTimeFlag,
        cover_agreement_time: :coverAgreementTime,
        cover_agreement_product: :coverAgreementProduct,
        cover_agreement_expense: :coverAgreementExpense,
        cover_sales_tax: :coverSalesTax,
        carry_over_unused: :carryOverUnused,
        allow_overruns: :allowOverruns,
        expired_days: :expiredDays,
        limit: :limit,
        expire_when_zero: :expireWhenZero,
        charge_to_firm: :chargeToFirm,
        employee_comp_rate: :employeeCompRate,
        employee_comp_not_exceed: :employeeCompNotExceed,
        comp_hourly_rate: :compHourlyRate,
        comp_limit_amount: :compLimitAmount,
        billing_cycle: :billingCycle,
        bill_one_time_flag: :billOneTimeFlag,
        billing_terms: :billingTerms,
        invoicing_cycle: :invoicingCycle,
        bill_to_company: :billToCompany,
        bill_to_contact: :billToContact,
        bill_to_site: :billToSite,
        bill_amount: :billAmount,
        taxable: :taxable,
        prorate_first_bill: :prorateFirstBill,
        bill_start_date: :billStartDate,
        tax_code: :taxCode,
        restrict_down_payment: :restrictDownPayment,
        prorate_flag: :prorateFlag,
        invoice_description: :invoiceDescription,
        top_comment: :topComment,
        bottom_comment: :bottomComment,
        work_role: :workRole,
        work_type: :workType,
        project_type: :projectType,
        invoice_template: :invoiceTemplate,
        bill_time: :billTime,
        bill_expenses: :billExpenses,
        bill_products: :billProducts,
        billable_time_invoice: :billableTimeInvoice,
        billable_expense_invoice: :billableExpenseInvoice,
        billable_product_invoice: :billableProductInvoice,
        currency: :currency,
        period_type: :periodType,
        auto_invoice_flag: :autoInvoiceFlag,
        next_invoice_date: :nextInvoiceDate,
        company_location: :companyLocation,
        agreement_status: :agreementStatus,
        _info: :_info,
        custom_fields: :customFields
      }
    end

    # Returns all the JSON keys this model knows about
    def self.acceptable_attributes
      attribute_map.values
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        name: :String,
        id: :Integer,
        type: :AgreementTypeReference,
        company: :CompanyReference,
        contact: :ContactReference,
        site: :SiteReference,
        sub_contract_company: :CompanyReference,
        sub_contract_contact: :ContactReference,
        parent_agreement: :AgreementReference,
        customer_po: :String,
        location: :SystemLocationReference,
        department: :SystemDepartmentReference,
        restrict_location_flag: :Boolean,
        restrict_department_flag: :Boolean,
        start_date: :Time,
        end_date: :Time,
        no_ending_date_flag: :Boolean,
        opportunity: :OpportunityReference,
        cancelled_flag: :Boolean,
        date_cancelled: :Time,
        reason_cancelled: :String,
        sla: :SLAReference,
        work_order: :String,
        internal_notes: :String,
        application_units: :String,
        application_limit: :Float,
        application_cycle: :String,
        application_unlimited_flag: :Boolean,
        one_time_flag: :Boolean,
        cover_agreement_time: :Boolean,
        cover_agreement_product: :Boolean,
        cover_agreement_expense: :Boolean,
        cover_sales_tax: :Boolean,
        carry_over_unused: :Boolean,
        allow_overruns: :Boolean,
        expired_days: :Integer,
        limit: :Integer,
        expire_when_zero: :Boolean,
        charge_to_firm: :Boolean,
        employee_comp_rate: :String,
        employee_comp_not_exceed: :String,
        comp_hourly_rate: :Float,
        comp_limit_amount: :Float,
        billing_cycle: :BillingCycleReference,
        bill_one_time_flag: :Boolean,
        billing_terms: :BillingTermsReference,
        invoicing_cycle: :String,
        bill_to_company: :CompanyReference,
        bill_to_contact: :ContactReference,
        bill_to_site: :SiteReference,
        bill_amount: :Float,
        taxable: :Boolean,
        prorate_first_bill: :Float,
        bill_start_date: :Time,
        tax_code: :TaxCodeReference,
        restrict_down_payment: :Boolean,
        prorate_flag: :Boolean,
        invoice_description: :String,
        top_comment: :Boolean,
        bottom_comment: :Boolean,
        work_role: :WorkRoleReference,
        work_type: :WorkTypeReference,
        project_type: :ProjectTypeReference,
        invoice_template: :InvoiceTemplateReference,
        bill_time: :String,
        bill_expenses: :String,
        bill_products: :String,
        billable_time_invoice: :Boolean,
        billable_expense_invoice: :Boolean,
        billable_product_invoice: :Boolean,
        currency: :CurrencyReference,
        period_type: :String,
        auto_invoice_flag: :Boolean,
        next_invoice_date: :String,
        company_location: :SystemLocationReference,
        agreement_status: :String,
        _info: :'Hash<String, String>',
        custom_fields: :'Array<CustomFieldValue>'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new(%i[
                restrict_location_flag
                restrict_department_flag
                no_ending_date_flag
                cancelled_flag
                application_units
                application_limit
                application_cycle
                application_unlimited_flag
                one_time_flag
                cover_agreement_time
                cover_agreement_product
                cover_agreement_expense
                cover_sales_tax
                carry_over_unused
                allow_overruns
                expired_days
                limit
                expire_when_zero
                charge_to_firm
                employee_comp_rate
                employee_comp_not_exceed
                comp_hourly_rate
                comp_limit_amount
                bill_one_time_flag
                invoicing_cycle
                bill_amount
                taxable
                prorate_first_bill
                restrict_down_payment
                prorate_flag
                top_comment
                bottom_comment
                bill_time
                bill_expenses
                bill_products
                billable_time_invoice
                billable_expense_invoice
                billable_product_invoice
                period_type
                auto_invoice_flag
                agreement_status
              ])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      raise ArgumentError, 'The input argument (attributes) must be a hash in `ConnectWise::Agreement` initialize method' unless attributes.is_a?(Hash)

      # check to see if the attribute exists and convert string to symbol for hash key
      attributes = attributes.each_with_object({}) do |(k, v), h|
        raise ArgumentError, "`#{k}` is not a valid attribute in `ConnectWise::Agreement`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect unless self.class.attribute_map.key?(k.to_sym)

        h[k.to_sym] = v
      end

      self.name = attributes[:name] if attributes.key?(:name)

      self.id = attributes[:id] if attributes.key?(:id)

      self.type = attributes[:type] if attributes.key?(:type)

      self.company = attributes[:company] if attributes.key?(:company)

      self.contact = attributes[:contact] if attributes.key?(:contact)

      self.site = attributes[:site] if attributes.key?(:site)

      self.sub_contract_company = attributes[:sub_contract_company] if attributes.key?(:sub_contract_company)

      self.sub_contract_contact = attributes[:sub_contract_contact] if attributes.key?(:sub_contract_contact)

      self.parent_agreement = attributes[:parent_agreement] if attributes.key?(:parent_agreement)

      self.customer_po = attributes[:customer_po] if attributes.key?(:customer_po)

      self.location = attributes[:location] if attributes.key?(:location)

      self.department = attributes[:department] if attributes.key?(:department)

      self.restrict_location_flag = attributes[:restrict_location_flag] if attributes.key?(:restrict_location_flag)

      self.restrict_department_flag = attributes[:restrict_department_flag] if attributes.key?(:restrict_department_flag)

      self.start_date = attributes[:start_date] if attributes.key?(:start_date)

      self.end_date = attributes[:end_date] if attributes.key?(:end_date)

      self.no_ending_date_flag = attributes[:no_ending_date_flag] if attributes.key?(:no_ending_date_flag)

      self.opportunity = attributes[:opportunity] if attributes.key?(:opportunity)

      self.cancelled_flag = attributes[:cancelled_flag] if attributes.key?(:cancelled_flag)

      self.date_cancelled = attributes[:date_cancelled] if attributes.key?(:date_cancelled)

      self.reason_cancelled = attributes[:reason_cancelled] if attributes.key?(:reason_cancelled)

      self.sla = attributes[:sla] if attributes.key?(:sla)

      self.work_order = attributes[:work_order] if attributes.key?(:work_order)

      self.internal_notes = attributes[:internal_notes] if attributes.key?(:internal_notes)

      self.application_units = attributes[:application_units] if attributes.key?(:application_units)

      self.application_limit = attributes[:application_limit] if attributes.key?(:application_limit)

      self.application_cycle = attributes[:application_cycle] if attributes.key?(:application_cycle)

      self.application_unlimited_flag = attributes[:application_unlimited_flag] if attributes.key?(:application_unlimited_flag)

      self.one_time_flag = attributes[:one_time_flag] if attributes.key?(:one_time_flag)

      self.cover_agreement_time = attributes[:cover_agreement_time] if attributes.key?(:cover_agreement_time)

      self.cover_agreement_product = attributes[:cover_agreement_product] if attributes.key?(:cover_agreement_product)

      self.cover_agreement_expense = attributes[:cover_agreement_expense] if attributes.key?(:cover_agreement_expense)

      self.cover_sales_tax = attributes[:cover_sales_tax] if attributes.key?(:cover_sales_tax)

      self.carry_over_unused = attributes[:carry_over_unused] if attributes.key?(:carry_over_unused)

      self.allow_overruns = attributes[:allow_overruns] if attributes.key?(:allow_overruns)

      self.expired_days = attributes[:expired_days] if attributes.key?(:expired_days)

      self.limit = attributes[:limit] if attributes.key?(:limit)

      self.expire_when_zero = attributes[:expire_when_zero] if attributes.key?(:expire_when_zero)

      self.charge_to_firm = attributes[:charge_to_firm] if attributes.key?(:charge_to_firm)

      self.employee_comp_rate = attributes[:employee_comp_rate] if attributes.key?(:employee_comp_rate)

      self.employee_comp_not_exceed = attributes[:employee_comp_not_exceed] if attributes.key?(:employee_comp_not_exceed)

      self.comp_hourly_rate = attributes[:comp_hourly_rate] if attributes.key?(:comp_hourly_rate)

      self.comp_limit_amount = attributes[:comp_limit_amount] if attributes.key?(:comp_limit_amount)

      self.billing_cycle = attributes[:billing_cycle] if attributes.key?(:billing_cycle)

      self.bill_one_time_flag = attributes[:bill_one_time_flag] if attributes.key?(:bill_one_time_flag)

      self.billing_terms = attributes[:billing_terms] if attributes.key?(:billing_terms)

      self.invoicing_cycle = attributes[:invoicing_cycle] if attributes.key?(:invoicing_cycle)

      self.bill_to_company = attributes[:bill_to_company] if attributes.key?(:bill_to_company)

      self.bill_to_contact = attributes[:bill_to_contact] if attributes.key?(:bill_to_contact)

      self.bill_to_site = attributes[:bill_to_site] if attributes.key?(:bill_to_site)

      self.bill_amount = attributes[:bill_amount] if attributes.key?(:bill_amount)

      self.taxable = attributes[:taxable] if attributes.key?(:taxable)

      self.prorate_first_bill = attributes[:prorate_first_bill] if attributes.key?(:prorate_first_bill)

      self.bill_start_date = attributes[:bill_start_date] if attributes.key?(:bill_start_date)

      self.tax_code = attributes[:tax_code] if attributes.key?(:tax_code)

      self.restrict_down_payment = attributes[:restrict_down_payment] if attributes.key?(:restrict_down_payment)

      self.prorate_flag = attributes[:prorate_flag] if attributes.key?(:prorate_flag)

      self.invoice_description = attributes[:invoice_description] if attributes.key?(:invoice_description)

      self.top_comment = attributes[:top_comment] if attributes.key?(:top_comment)

      self.bottom_comment = attributes[:bottom_comment] if attributes.key?(:bottom_comment)

      self.work_role = attributes[:work_role] if attributes.key?(:work_role)

      self.work_type = attributes[:work_type] if attributes.key?(:work_type)

      self.project_type = attributes[:project_type] if attributes.key?(:project_type)

      self.invoice_template = attributes[:invoice_template] if attributes.key?(:invoice_template)

      self.bill_time = attributes[:bill_time] if attributes.key?(:bill_time)

      self.bill_expenses = attributes[:bill_expenses] if attributes.key?(:bill_expenses)

      self.bill_products = attributes[:bill_products] if attributes.key?(:bill_products)

      self.billable_time_invoice = attributes[:billable_time_invoice] if attributes.key?(:billable_time_invoice)

      self.billable_expense_invoice = attributes[:billable_expense_invoice] if attributes.key?(:billable_expense_invoice)

      self.billable_product_invoice = attributes[:billable_product_invoice] if attributes.key?(:billable_product_invoice)

      self.currency = attributes[:currency] if attributes.key?(:currency)

      self.period_type = attributes[:period_type] if attributes.key?(:period_type)

      self.auto_invoice_flag = attributes[:auto_invoice_flag] if attributes.key?(:auto_invoice_flag)

      self.next_invoice_date = attributes[:next_invoice_date] if attributes.key?(:next_invoice_date)

      self.company_location = attributes[:company_location] if attributes.key?(:company_location)

      self.agreement_status = attributes[:agreement_status] if attributes.key?(:agreement_status)

      if attributes.key?(:_info) && (value = attributes[:_info]).is_a?(Hash)
        self._info = value
      end

      return unless attributes.key?(:custom_fields)
      return unless (value = attributes[:custom_fields]).is_a?(Array)

      self.custom_fields = value
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = []
      invalid_properties.push('invalid value for "name", name cannot be nil.') if @name.nil?

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if @name.nil?

      application_units_validator = EnumAttributeValidator.new('String', %w[Amount Hours Incidents])
      return false unless application_units_validator.valid?(@application_units)

      application_cycle_validator = EnumAttributeValidator.new('String', %w[Contract2Weeks Contract4Weeks ContractYear CalendarMonth CalendarQuarter CalendarWeek ContractQuarter CalendarYear])
      return false unless application_cycle_validator.valid?(@application_cycle)

      employee_comp_rate_validator = EnumAttributeValidator.new('String', %w[Actual Hourly])
      return false unless employee_comp_rate_validator.valid?(@employee_comp_rate)

      employee_comp_not_exceed_validator = EnumAttributeValidator.new('String', %w[Billing Amount Percent])
      return false unless employee_comp_not_exceed_validator.valid?(@employee_comp_not_exceed)

      invoicing_cycle_validator = EnumAttributeValidator.new('String', %w[ContractYear CalendarYear])
      return false unless invoicing_cycle_validator.valid?(@invoicing_cycle)

      bill_time_validator = EnumAttributeValidator.new('String', %w[Billable DoNotBill NoCharge NoDefault])
      return false unless bill_time_validator.valid?(@bill_time)

      bill_expenses_validator = EnumAttributeValidator.new('String', %w[Billable DoNotBill NoCharge NoDefault])
      return false unless bill_expenses_validator.valid?(@bill_expenses)

      bill_products_validator = EnumAttributeValidator.new('String', %w[Billable DoNotBill NoCharge NoDefault])
      return false unless bill_products_validator.valid?(@bill_products)

      period_type_validator = EnumAttributeValidator.new('String', %w[Current Future Both Undefined])
      return false unless period_type_validator.valid?(@period_type)

      agreement_status_validator = EnumAttributeValidator.new('String', %w[Active Cancelled Expired Inactive])
      return false unless agreement_status_validator.valid?(@agreement_status)

      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] application_units Object to be assigned
    def application_units=(application_units)
      validator = EnumAttributeValidator.new('String', %w[Amount Hours Incidents])
      raise ArgumentError, "invalid value for \"application_units\", must be one of #{validator.allowable_values}." unless validator.valid?(application_units)

      @application_units = application_units
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] application_cycle Object to be assigned
    def application_cycle=(application_cycle)
      validator = EnumAttributeValidator.new('String', %w[Contract2Weeks Contract4Weeks ContractYear CalendarMonth CalendarQuarter CalendarWeek ContractQuarter CalendarYear])
      raise ArgumentError, "invalid value for \"application_cycle\", must be one of #{validator.allowable_values}." unless validator.valid?(application_cycle)

      @application_cycle = application_cycle
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] employee_comp_rate Object to be assigned
    def employee_comp_rate=(employee_comp_rate)
      validator = EnumAttributeValidator.new('String', %w[Actual Hourly])
      raise ArgumentError, "invalid value for \"employee_comp_rate\", must be one of #{validator.allowable_values}." unless validator.valid?(employee_comp_rate)

      @employee_comp_rate = employee_comp_rate
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] employee_comp_not_exceed Object to be assigned
    def employee_comp_not_exceed=(employee_comp_not_exceed)
      validator = EnumAttributeValidator.new('String', %w[Billing Amount Percent])
      raise ArgumentError, "invalid value for \"employee_comp_not_exceed\", must be one of #{validator.allowable_values}." unless validator.valid?(employee_comp_not_exceed)

      @employee_comp_not_exceed = employee_comp_not_exceed
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] invoicing_cycle Object to be assigned
    def invoicing_cycle=(invoicing_cycle)
      validator = EnumAttributeValidator.new('String', %w[ContractYear CalendarYear])
      raise ArgumentError, "invalid value for \"invoicing_cycle\", must be one of #{validator.allowable_values}." unless validator.valid?(invoicing_cycle)

      @invoicing_cycle = invoicing_cycle
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] bill_time Object to be assigned
    def bill_time=(bill_time)
      validator = EnumAttributeValidator.new('String', %w[Billable DoNotBill NoCharge NoDefault])
      raise ArgumentError, "invalid value for \"bill_time\", must be one of #{validator.allowable_values}." unless validator.valid?(bill_time)

      @bill_time = bill_time
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] bill_expenses Object to be assigned
    def bill_expenses=(bill_expenses)
      validator = EnumAttributeValidator.new('String', %w[Billable DoNotBill NoCharge NoDefault])
      raise ArgumentError, "invalid value for \"bill_expenses\", must be one of #{validator.allowable_values}." unless validator.valid?(bill_expenses)

      @bill_expenses = bill_expenses
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] bill_products Object to be assigned
    def bill_products=(bill_products)
      validator = EnumAttributeValidator.new('String', %w[Billable DoNotBill NoCharge NoDefault])
      raise ArgumentError, "invalid value for \"bill_products\", must be one of #{validator.allowable_values}." unless validator.valid?(bill_products)

      @bill_products = bill_products
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] period_type Object to be assigned
    def period_type=(period_type)
      validator = EnumAttributeValidator.new('String', %w[Current Future Both Undefined])
      raise ArgumentError, "invalid value for \"period_type\", must be one of #{validator.allowable_values}." unless validator.valid?(period_type)

      @period_type = period_type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] agreement_status Object to be assigned
    def agreement_status=(agreement_status)
      validator = EnumAttributeValidator.new('String', %w[Active Cancelled Expired Inactive])
      raise ArgumentError, "invalid value for \"agreement_status\", must be one of #{validator.allowable_values}." unless validator.valid?(agreement_status)

      @agreement_status = agreement_status
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        name == other.name &&
        id == other.id &&
        type == other.type &&
        company == other.company &&
        contact == other.contact &&
        site == other.site &&
        sub_contract_company == other.sub_contract_company &&
        sub_contract_contact == other.sub_contract_contact &&
        parent_agreement == other.parent_agreement &&
        customer_po == other.customer_po &&
        location == other.location &&
        department == other.department &&
        restrict_location_flag == other.restrict_location_flag &&
        restrict_department_flag == other.restrict_department_flag &&
        start_date == other.start_date &&
        end_date == other.end_date &&
        no_ending_date_flag == other.no_ending_date_flag &&
        opportunity == other.opportunity &&
        cancelled_flag == other.cancelled_flag &&
        date_cancelled == other.date_cancelled &&
        reason_cancelled == other.reason_cancelled &&
        sla == other.sla &&
        work_order == other.work_order &&
        internal_notes == other.internal_notes &&
        application_units == other.application_units &&
        application_limit == other.application_limit &&
        application_cycle == other.application_cycle &&
        application_unlimited_flag == other.application_unlimited_flag &&
        one_time_flag == other.one_time_flag &&
        cover_agreement_time == other.cover_agreement_time &&
        cover_agreement_product == other.cover_agreement_product &&
        cover_agreement_expense == other.cover_agreement_expense &&
        cover_sales_tax == other.cover_sales_tax &&
        carry_over_unused == other.carry_over_unused &&
        allow_overruns == other.allow_overruns &&
        expired_days == other.expired_days &&
        limit == other.limit &&
        expire_when_zero == other.expire_when_zero &&
        charge_to_firm == other.charge_to_firm &&
        employee_comp_rate == other.employee_comp_rate &&
        employee_comp_not_exceed == other.employee_comp_not_exceed &&
        comp_hourly_rate == other.comp_hourly_rate &&
        comp_limit_amount == other.comp_limit_amount &&
        billing_cycle == other.billing_cycle &&
        bill_one_time_flag == other.bill_one_time_flag &&
        billing_terms == other.billing_terms &&
        invoicing_cycle == other.invoicing_cycle &&
        bill_to_company == other.bill_to_company &&
        bill_to_contact == other.bill_to_contact &&
        bill_to_site == other.bill_to_site &&
        bill_amount == other.bill_amount &&
        taxable == other.taxable &&
        prorate_first_bill == other.prorate_first_bill &&
        bill_start_date == other.bill_start_date &&
        tax_code == other.tax_code &&
        restrict_down_payment == other.restrict_down_payment &&
        prorate_flag == other.prorate_flag &&
        invoice_description == other.invoice_description &&
        top_comment == other.top_comment &&
        bottom_comment == other.bottom_comment &&
        work_role == other.work_role &&
        work_type == other.work_type &&
        project_type == other.project_type &&
        invoice_template == other.invoice_template &&
        bill_time == other.bill_time &&
        bill_expenses == other.bill_expenses &&
        bill_products == other.bill_products &&
        billable_time_invoice == other.billable_time_invoice &&
        billable_expense_invoice == other.billable_expense_invoice &&
        billable_product_invoice == other.billable_product_invoice &&
        currency == other.currency &&
        period_type == other.period_type &&
        auto_invoice_flag == other.auto_invoice_flag &&
        next_invoice_date == other.next_invoice_date &&
        company_location == other.company_location &&
        agreement_status == other.agreement_status &&
        _info == other._info &&
        custom_fields == other.custom_fields
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(other)
      self == other
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [name, id, type, company, contact, site, sub_contract_company, sub_contract_contact, parent_agreement, customer_po, location, department, restrict_location_flag, restrict_department_flag, start_date, end_date, no_ending_date_flag, opportunity, cancelled_flag, date_cancelled, reason_cancelled, sla, work_order, internal_notes, application_units, application_limit, application_cycle, application_unlimited_flag, one_time_flag, cover_agreement_time, cover_agreement_product, cover_agreement_expense, cover_sales_tax, carry_over_unused, allow_overruns, expired_days, limit, expire_when_zero, charge_to_firm, employee_comp_rate, employee_comp_not_exceed, comp_hourly_rate, comp_limit_amount, billing_cycle, bill_one_time_flag, billing_terms, invoicing_cycle, bill_to_company, bill_to_contact, bill_to_site, bill_amount, taxable, prorate_first_bill, bill_start_date, tax_code, restrict_down_payment, prorate_flag, invoice_description, top_comment, bottom_comment, work_role, work_type, project_type, invoice_template, bill_time, bill_expenses, bill_products, billable_time_invoice, billable_expense_invoice, billable_product_invoice, currency, period_type, auto_invoice_flag, next_invoice_date, company_location, agreement_status, _info, custom_fields].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      new.build_from_hash(attributes)
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      attributes = attributes.transform_keys(&:to_sym)
      self.class.openapi_types.each_pair do |key, type|
        if attributes[self.class.attribute_map[key]].nil? && self.class.openapi_nullable.include?(key)
          send("#{key}=", nil)
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize(::Regexp.last_match(1), v) }) if attributes[self.class.attribute_map[key]].is_a?(Array)
        elsif !attributes[self.class.attribute_map[key]].nil?
          send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = ConnectWise.const_get(type)
        klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end

# #Connectwise Manage Public Endpoints
#
# No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
#
# The version of the OpenAPI document: 2025.1
#
# Generated by: https://openapi-generator.tech
# Generator version: 7.12.0
#

require 'date'
require 'time'

module ConnectWise
  class CatalogItem
    #  Max length: 75;
    attr_accessor :identifier

    #  Max length: 60;
    attr_accessor :description

    attr_accessor :subcategory, :type, :id, :inactive_flag, :serialized_flag, :serialized_cost_flag, :phase_product_flag, :unit_of_measure, :min_stock_level, :price, :cost, :price_attribute, :taxable_flag, :drop_ship_flag, :special_order_flag, :manufacturer, :vendor, :notes, :sla, :entity_type, :recurring_flag, :recurring_revenue, :recurring_cost, :recurring_one_time_flag, :recurring_bill_cycle, :recurring_cycle_type, :calculated_price_flag, :calculated_cost_flag, :category, :calculated_price, :calculated_cost, :billable_option, :connect_wise_id, :agreement_type, :markup_percentage, :markup_flag, :auto_update_unit_cost_flag, :auto_update_unit_price_flag, :_info, :custom_fields

    #  Max length: 6000;
    attr_accessor :customer_description

    # Defaults to Non-Inventory.
    attr_accessor :product_class

    #  Max length: 50;
    attr_accessor :manufacturer_part_number

    #  Max length: 50;
    attr_accessor :vendor_sku

    #  Max length: 50;
    attr_accessor :integration_x_ref

    class EnumAttributeValidator
      attr_reader :datatype, :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        identifier: :identifier,
        description: :description,
        subcategory: :subcategory,
        type: :type,
        customer_description: :customerDescription,
        id: :id,
        inactive_flag: :inactiveFlag,
        product_class: :productClass,
        serialized_flag: :serializedFlag,
        serialized_cost_flag: :serializedCostFlag,
        phase_product_flag: :phaseProductFlag,
        unit_of_measure: :unitOfMeasure,
        min_stock_level: :minStockLevel,
        price: :price,
        cost: :cost,
        price_attribute: :priceAttribute,
        taxable_flag: :taxableFlag,
        drop_ship_flag: :dropShipFlag,
        special_order_flag: :specialOrderFlag,
        manufacturer: :manufacturer,
        manufacturer_part_number: :manufacturerPartNumber,
        vendor: :vendor,
        vendor_sku: :vendorSku,
        notes: :notes,
        integration_x_ref: :integrationXRef,
        sla: :sla,
        entity_type: :entityType,
        recurring_flag: :recurringFlag,
        recurring_revenue: :recurringRevenue,
        recurring_cost: :recurringCost,
        recurring_one_time_flag: :recurringOneTimeFlag,
        recurring_bill_cycle: :recurringBillCycle,
        recurring_cycle_type: :recurringCycleType,
        calculated_price_flag: :calculatedPriceFlag,
        calculated_cost_flag: :calculatedCostFlag,
        category: :category,
        calculated_price: :calculatedPrice,
        calculated_cost: :calculatedCost,
        billable_option: :billableOption,
        connect_wise_id: :connectWiseID,
        agreement_type: :agreementType,
        markup_percentage: :markupPercentage,
        markup_flag: :markupFlag,
        auto_update_unit_cost_flag: :autoUpdateUnitCostFlag,
        auto_update_unit_price_flag: :autoUpdateUnitPriceFlag,
        _info: :_info,
        custom_fields: :customFields
      }
    end

    # Returns attribute mapping this model knows about
    def self.acceptable_attribute_map
      attribute_map
    end

    # Returns all the JSON keys this model knows about
    def self.acceptable_attributes
      acceptable_attribute_map.values
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        identifier: :String,
        description: :String,
        subcategory: :ProductSubCategoryReference,
        type: :ProductTypeReference,
        customer_description: :String,
        id: :Integer,
        inactive_flag: :Boolean,
        product_class: :String,
        serialized_flag: :Boolean,
        serialized_cost_flag: :Boolean,
        phase_product_flag: :Boolean,
        unit_of_measure: :UnitOfMeasureReference,
        min_stock_level: :Integer,
        price: :Float,
        cost: :Float,
        price_attribute: :String,
        taxable_flag: :Boolean,
        drop_ship_flag: :Boolean,
        special_order_flag: :Boolean,
        manufacturer: :ManufacturerReference,
        manufacturer_part_number: :String,
        vendor: :CompanyReference,
        vendor_sku: :String,
        notes: :String,
        integration_x_ref: :String,
        sla: :SLAReference,
        entity_type: :EntityTypeReference,
        recurring_flag: :Boolean,
        recurring_revenue: :Float,
        recurring_cost: :Float,
        recurring_one_time_flag: :Boolean,
        recurring_bill_cycle: :BillingCycleReference,
        recurring_cycle_type: :String,
        calculated_price_flag: :Boolean,
        calculated_cost_flag: :Boolean,
        category: :ProductCategoryReference,
        calculated_price: :Float,
        calculated_cost: :Float,
        billable_option: :String,
        connect_wise_id: :String,
        agreement_type: :AgreementTypeReference,
        markup_percentage: :Float,
        markup_flag: :Boolean,
        auto_update_unit_cost_flag: :Boolean,
        auto_update_unit_price_flag: :Boolean,
        _info: :'Hash<String, String>',
        custom_fields: :'Array<CustomFieldValue>'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new(%i[
                inactive_flag
                product_class
                serialized_flag
                serialized_cost_flag
                phase_product_flag
                min_stock_level
                price
                cost
                price_attribute
                taxable_flag
                drop_ship_flag
                special_order_flag
                recurring_flag
                recurring_revenue
                recurring_cost
                recurring_one_time_flag
                recurring_cycle_type
                calculated_price_flag
                calculated_cost_flag
                calculated_price
                calculated_cost
                billable_option
                markup_percentage
                markup_flag
                auto_update_unit_cost_flag
                auto_update_unit_price_flag
              ])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      raise ArgumentError, 'The input argument (attributes) must be a hash in `ConnectWise::CatalogItem` initialize method' unless attributes.is_a?(Hash)

      # check to see if the attribute exists and convert string to symbol for hash key
      acceptable_attribute_map = self.class.acceptable_attribute_map
      attributes = attributes.each_with_object({}) do |(k, v), h|
        raise ArgumentError, "`#{k}` is not a valid attribute in `ConnectWise::CatalogItem`. Please check the name to make sure it's valid. List of attributes: " + acceptable_attribute_map.keys.inspect unless acceptable_attribute_map.key?(k.to_sym)

        h[k.to_sym] = v
      end

      self.identifier = (attributes[:identifier] if attributes.key?(:identifier))

      self.description = (attributes[:description] if attributes.key?(:description))

      self.subcategory = (attributes[:subcategory] if attributes.key?(:subcategory))

      self.type = (attributes[:type] if attributes.key?(:type))

      self.customer_description = (attributes[:customer_description] if attributes.key?(:customer_description))

      self.id = attributes[:id] if attributes.key?(:id)

      self.inactive_flag = attributes[:inactive_flag] if attributes.key?(:inactive_flag)

      self.product_class = attributes[:product_class] if attributes.key?(:product_class)

      self.serialized_flag = attributes[:serialized_flag] if attributes.key?(:serialized_flag)

      self.serialized_cost_flag = attributes[:serialized_cost_flag] if attributes.key?(:serialized_cost_flag)

      self.phase_product_flag = attributes[:phase_product_flag] if attributes.key?(:phase_product_flag)

      self.unit_of_measure = attributes[:unit_of_measure] if attributes.key?(:unit_of_measure)

      self.min_stock_level = attributes[:min_stock_level] if attributes.key?(:min_stock_level)

      self.price = attributes[:price] if attributes.key?(:price)

      self.cost = attributes[:cost] if attributes.key?(:cost)

      self.price_attribute = attributes[:price_attribute] if attributes.key?(:price_attribute)

      self.taxable_flag = attributes[:taxable_flag] if attributes.key?(:taxable_flag)

      self.drop_ship_flag = attributes[:drop_ship_flag] if attributes.key?(:drop_ship_flag)

      self.special_order_flag = attributes[:special_order_flag] if attributes.key?(:special_order_flag)

      self.manufacturer = attributes[:manufacturer] if attributes.key?(:manufacturer)

      self.manufacturer_part_number = attributes[:manufacturer_part_number] if attributes.key?(:manufacturer_part_number)

      self.vendor = attributes[:vendor] if attributes.key?(:vendor)

      self.vendor_sku = attributes[:vendor_sku] if attributes.key?(:vendor_sku)

      self.notes = attributes[:notes] if attributes.key?(:notes)

      self.integration_x_ref = attributes[:integration_x_ref] if attributes.key?(:integration_x_ref)

      self.sla = attributes[:sla] if attributes.key?(:sla)

      self.entity_type = attributes[:entity_type] if attributes.key?(:entity_type)

      self.recurring_flag = attributes[:recurring_flag] if attributes.key?(:recurring_flag)

      self.recurring_revenue = attributes[:recurring_revenue] if attributes.key?(:recurring_revenue)

      self.recurring_cost = attributes[:recurring_cost] if attributes.key?(:recurring_cost)

      self.recurring_one_time_flag = attributes[:recurring_one_time_flag] if attributes.key?(:recurring_one_time_flag)

      self.recurring_bill_cycle = attributes[:recurring_bill_cycle] if attributes.key?(:recurring_bill_cycle)

      self.recurring_cycle_type = attributes[:recurring_cycle_type] if attributes.key?(:recurring_cycle_type)

      self.calculated_price_flag = attributes[:calculated_price_flag] if attributes.key?(:calculated_price_flag)

      self.calculated_cost_flag = attributes[:calculated_cost_flag] if attributes.key?(:calculated_cost_flag)

      self.category = attributes[:category] if attributes.key?(:category)

      self.calculated_price = attributes[:calculated_price] if attributes.key?(:calculated_price)

      self.calculated_cost = attributes[:calculated_cost] if attributes.key?(:calculated_cost)

      self.billable_option = attributes[:billable_option] if attributes.key?(:billable_option)

      self.connect_wise_id = attributes[:connect_wise_id] if attributes.key?(:connect_wise_id)

      self.agreement_type = attributes[:agreement_type] if attributes.key?(:agreement_type)

      self.markup_percentage = attributes[:markup_percentage] if attributes.key?(:markup_percentage)

      self.markup_flag = attributes[:markup_flag] if attributes.key?(:markup_flag)

      self.auto_update_unit_cost_flag = attributes[:auto_update_unit_cost_flag] if attributes.key?(:auto_update_unit_cost_flag)

      self.auto_update_unit_price_flag = attributes[:auto_update_unit_price_flag] if attributes.key?(:auto_update_unit_price_flag)

      if attributes.key?(:_info) && (value = attributes[:_info]).is_a?(Hash)
        self._info = value
      end

      return unless attributes.key?(:custom_fields)

      if (value = attributes[:custom_fields]).is_a?(Array)
        self.custom_fields = value
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      warn '[DEPRECATED] the `list_invalid_properties` method is obsolete'
      invalid_properties = []
      invalid_properties.push('invalid value for "identifier", identifier cannot be nil.') if @identifier.nil?

      invalid_properties.push('invalid value for "description", description cannot be nil.') if @description.nil?

      invalid_properties.push('invalid value for "subcategory", subcategory cannot be nil.') if @subcategory.nil?

      invalid_properties.push('invalid value for "type", type cannot be nil.') if @type.nil?

      invalid_properties.push('invalid value for "customer_description", customer_description cannot be nil.') if @customer_description.nil?

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      warn '[DEPRECATED] the `valid?` method is obsolete'
      return false if @identifier.nil?
      return false if @description.nil?
      return false if @subcategory.nil?
      return false if @type.nil?
      return false if @customer_description.nil?

      product_class_validator = EnumAttributeValidator.new('String', %w[Agreement Bundle Inventory NonInventory Service])
      return false unless product_class_validator.valid?(@product_class)

      price_attribute_validator = EnumAttributeValidator.new('String', %w[FixedFee NotToExceed OverrideRate TimeAndMaterials])
      return false unless price_attribute_validator.valid?(@price_attribute)

      recurring_cycle_type_validator = EnumAttributeValidator.new('String', %w[ContractYear CalendarYear])
      return false unless recurring_cycle_type_validator.valid?(@recurring_cycle_type)

      billable_option_validator = EnumAttributeValidator.new('String', %w[Billable DoNotBill NoCharge NoDefault])
      return false unless billable_option_validator.valid?(@billable_option)

      true
    end

    # Custom attribute writer method with validation
    # @param [Object] identifier Value to be assigned
    def identifier=(identifier)
      raise ArgumentError, 'identifier cannot be nil' if identifier.nil?

      @identifier = identifier
    end

    # Custom attribute writer method with validation
    # @param [Object] description Value to be assigned
    def description=(description)
      raise ArgumentError, 'description cannot be nil' if description.nil?

      @description = description
    end

    # Custom attribute writer method with validation
    # @param [Object] subcategory Value to be assigned
    def subcategory=(subcategory)
      raise ArgumentError, 'subcategory cannot be nil' if subcategory.nil?

      @subcategory = subcategory
    end

    # Custom attribute writer method with validation
    # @param [Object] type Value to be assigned
    def type=(type)
      raise ArgumentError, 'type cannot be nil' if type.nil?

      @type = type
    end

    # Custom attribute writer method with validation
    # @param [Object] customer_description Value to be assigned
    def customer_description=(customer_description)
      raise ArgumentError, 'customer_description cannot be nil' if customer_description.nil?

      @customer_description = customer_description
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] product_class Object to be assigned
    def product_class=(product_class)
      validator = EnumAttributeValidator.new('String', %w[Agreement Bundle Inventory NonInventory Service])
      raise ArgumentError, "invalid value for \"product_class\", must be one of #{validator.allowable_values}." unless validator.valid?(product_class)

      @product_class = product_class
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] price_attribute Object to be assigned
    def price_attribute=(price_attribute)
      validator = EnumAttributeValidator.new('String', %w[FixedFee NotToExceed OverrideRate TimeAndMaterials])
      raise ArgumentError, "invalid value for \"price_attribute\", must be one of #{validator.allowable_values}." unless validator.valid?(price_attribute)

      @price_attribute = price_attribute
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] recurring_cycle_type Object to be assigned
    def recurring_cycle_type=(recurring_cycle_type)
      validator = EnumAttributeValidator.new('String', %w[ContractYear CalendarYear])
      raise ArgumentError, "invalid value for \"recurring_cycle_type\", must be one of #{validator.allowable_values}." unless validator.valid?(recurring_cycle_type)

      @recurring_cycle_type = recurring_cycle_type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] billable_option Object to be assigned
    def billable_option=(billable_option)
      validator = EnumAttributeValidator.new('String', %w[Billable DoNotBill NoCharge NoDefault])
      raise ArgumentError, "invalid value for \"billable_option\", must be one of #{validator.allowable_values}." unless validator.valid?(billable_option)

      @billable_option = billable_option
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        identifier == other.identifier &&
        description == other.description &&
        subcategory == other.subcategory &&
        type == other.type &&
        customer_description == other.customer_description &&
        id == other.id &&
        inactive_flag == other.inactive_flag &&
        product_class == other.product_class &&
        serialized_flag == other.serialized_flag &&
        serialized_cost_flag == other.serialized_cost_flag &&
        phase_product_flag == other.phase_product_flag &&
        unit_of_measure == other.unit_of_measure &&
        min_stock_level == other.min_stock_level &&
        price == other.price &&
        cost == other.cost &&
        price_attribute == other.price_attribute &&
        taxable_flag == other.taxable_flag &&
        drop_ship_flag == other.drop_ship_flag &&
        special_order_flag == other.special_order_flag &&
        manufacturer == other.manufacturer &&
        manufacturer_part_number == other.manufacturer_part_number &&
        vendor == other.vendor &&
        vendor_sku == other.vendor_sku &&
        notes == other.notes &&
        integration_x_ref == other.integration_x_ref &&
        sla == other.sla &&
        entity_type == other.entity_type &&
        recurring_flag == other.recurring_flag &&
        recurring_revenue == other.recurring_revenue &&
        recurring_cost == other.recurring_cost &&
        recurring_one_time_flag == other.recurring_one_time_flag &&
        recurring_bill_cycle == other.recurring_bill_cycle &&
        recurring_cycle_type == other.recurring_cycle_type &&
        calculated_price_flag == other.calculated_price_flag &&
        calculated_cost_flag == other.calculated_cost_flag &&
        category == other.category &&
        calculated_price == other.calculated_price &&
        calculated_cost == other.calculated_cost &&
        billable_option == other.billable_option &&
        connect_wise_id == other.connect_wise_id &&
        agreement_type == other.agreement_type &&
        markup_percentage == other.markup_percentage &&
        markup_flag == other.markup_flag &&
        auto_update_unit_cost_flag == other.auto_update_unit_cost_flag &&
        auto_update_unit_price_flag == other.auto_update_unit_price_flag &&
        _info == other._info &&
        custom_fields == other.custom_fields
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(other)
      self == other
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [identifier, description, subcategory, type, customer_description, id, inactive_flag, product_class, serialized_flag, serialized_cost_flag, phase_product_flag, unit_of_measure, min_stock_level, price, cost, price_attribute, taxable_flag, drop_ship_flag, special_order_flag, manufacturer, manufacturer_part_number, vendor, vendor_sku, notes, integration_x_ref, sla, entity_type, recurring_flag, recurring_revenue, recurring_cost, recurring_one_time_flag, recurring_bill_cycle, recurring_cycle_type, calculated_price_flag, calculated_cost_flag, category, calculated_price, calculated_cost, billable_option, connect_wise_id, agreement_type, markup_percentage, markup_flag, auto_update_unit_cost_flag, auto_update_unit_price_flag, _info, custom_fields].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      attributes = attributes.transform_keys(&:to_sym)
      transformed_hash = {}
      openapi_types.each_pair do |key, type|
        if attributes.key?(attribute_map[key]) && attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = nil
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          transformed_hash["#{key}"] = attributes[attribute_map[key]].map { |v| _deserialize(::Regexp.last_match(1), v) } if attributes[attribute_map[key]].is_a?(Array)
        elsif !attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = _deserialize(type, attributes[attribute_map[key]])
        end
      end
      new(transformed_hash)
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def self._deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = ConnectWise.const_get(type)
        klass.respond_to?(:openapi_any_of) || klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end

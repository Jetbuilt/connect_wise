# #Connectwise Manage Public Endpoints
#
# No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
#
# The version of the OpenAPI document: 2025.1
#
# Generated by: https://openapi-generator.tech
# Generator version: 7.12.0
#

require 'date'
require 'time'

module ConnectWise
  class CompanyConfiguration
    #  Max length: 100;
    attr_accessor :name

    attr_accessor :type, :company, :id, :status, :contact, :site, :location_id, :location, :business_unit_id, :department, :purchase_date, :installation_date, :installed_by, :warranty_expiration_date, :vendor_notes, :notes, :bill_flag, :backup_successes, :backup_incomplete, :backup_failed, :backup_restores, :last_backup_date, :backup_billable_space_gb, :backup_protected_device_list, :backup_year, :backup_month, :local_hard_drives, :parent_configuration_id, :vendor, :manufacturer, :questions, :active_flag, :sla, :mobile_guid, :display_vendor_flag, :company_location_id, :show_remote_flag, :show_automate_flag, :needs_renewal_flag, :_info, :custom_fields

    #  Max length: 100;
    attr_accessor :device_identifier

    #  Max length: 250;
    attr_accessor :serial_number

    #  Max length: 50;
    attr_accessor :model_number

    #  Max length: 50;
    attr_accessor :tag_number

    #  Max length: 25;
    attr_accessor :mac_address

    #  Max length: 100;
    attr_accessor :last_login_name

    #  Max length: 50;
    attr_accessor :backup_server_name

    #  Max length: 50;
    attr_accessor :ip_address

    #  Max length: 50;
    attr_accessor :default_gateway

    #  Max length: 250;
    attr_accessor :os_type

    #  Max length: 250;
    attr_accessor :os_info

    #  Max length: 100;
    attr_accessor :cpu_speed

    #  Max length: 25;
    attr_accessor :ram

    #  Max length: 1000;
    attr_accessor :management_link

    #  Max length: 1000;
    attr_accessor :remote_link

    #  Max length: 50;
    attr_accessor :manufacturer_part_number

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        name: :name,
        type: :type,
        company: :company,
        id: :id,
        status: :status,
        contact: :contact,
        site: :site,
        location_id: :locationId,
        location: :location,
        business_unit_id: :businessUnitId,
        department: :department,
        device_identifier: :deviceIdentifier,
        serial_number: :serialNumber,
        model_number: :modelNumber,
        tag_number: :tagNumber,
        purchase_date: :purchaseDate,
        installation_date: :installationDate,
        installed_by: :installedBy,
        warranty_expiration_date: :warrantyExpirationDate,
        vendor_notes: :vendorNotes,
        notes: :notes,
        mac_address: :macAddress,
        last_login_name: :lastLoginName,
        bill_flag: :billFlag,
        backup_successes: :backupSuccesses,
        backup_incomplete: :backupIncomplete,
        backup_failed: :backupFailed,
        backup_restores: :backupRestores,
        last_backup_date: :lastBackupDate,
        backup_server_name: :backupServerName,
        backup_billable_space_gb: :backupBillableSpaceGb,
        backup_protected_device_list: :backupProtectedDeviceList,
        backup_year: :backupYear,
        backup_month: :backupMonth,
        ip_address: :ipAddress,
        default_gateway: :defaultGateway,
        os_type: :osType,
        os_info: :osInfo,
        cpu_speed: :cpuSpeed,
        ram: :ram,
        local_hard_drives: :localHardDrives,
        parent_configuration_id: :parentConfigurationId,
        vendor: :vendor,
        manufacturer: :manufacturer,
        questions: :questions,
        active_flag: :activeFlag,
        management_link: :managementLink,
        remote_link: :remoteLink,
        sla: :sla,
        mobile_guid: :mobileGuid,
        display_vendor_flag: :displayVendorFlag,
        company_location_id: :companyLocationId,
        show_remote_flag: :showRemoteFlag,
        show_automate_flag: :showAutomateFlag,
        needs_renewal_flag: :needsRenewalFlag,
        manufacturer_part_number: :manufacturerPartNumber,
        _info: :_info,
        custom_fields: :customFields
      }
    end

    # Returns attribute mapping this model knows about
    def self.acceptable_attribute_map
      attribute_map
    end

    # Returns all the JSON keys this model knows about
    def self.acceptable_attributes
      acceptable_attribute_map.values
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        name: :String,
        type: :ConfigurationTypeReference,
        company: :CompanyReference,
        id: :Integer,
        status: :ConfigurationStatusReference,
        contact: :ContactReference,
        site: :SiteReference,
        location_id: :Integer,
        location: :SystemLocationReference,
        business_unit_id: :Integer,
        department: :SystemDepartmentReference,
        device_identifier: :String,
        serial_number: :String,
        model_number: :String,
        tag_number: :String,
        purchase_date: :Time,
        installation_date: :Time,
        installed_by: :MemberReference,
        warranty_expiration_date: :Time,
        vendor_notes: :String,
        notes: :String,
        mac_address: :String,
        last_login_name: :String,
        bill_flag: :Boolean,
        backup_successes: :Integer,
        backup_incomplete: :Integer,
        backup_failed: :Integer,
        backup_restores: :Integer,
        last_backup_date: :Time,
        backup_server_name: :String,
        backup_billable_space_gb: :Float,
        backup_protected_device_list: :String,
        backup_year: :Integer,
        backup_month: :Integer,
        ip_address: :String,
        default_gateway: :String,
        os_type: :String,
        os_info: :String,
        cpu_speed: :String,
        ram: :String,
        local_hard_drives: :String,
        parent_configuration_id: :Integer,
        vendor: :CompanyReference,
        manufacturer: :ManufacturerReference,
        questions: :'Array<ConfigurationQuestion>',
        active_flag: :Boolean,
        management_link: :String,
        remote_link: :String,
        sla: :SLAReference,
        mobile_guid: :String,
        display_vendor_flag: :Boolean,
        company_location_id: :Integer,
        show_remote_flag: :Boolean,
        show_automate_flag: :Boolean,
        needs_renewal_flag: :Boolean,
        manufacturer_part_number: :String,
        _info: :'Hash<String, String>',
        custom_fields: :'Array<CustomFieldValue>'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new(%i[
                location_id
                business_unit_id
                bill_flag
                backup_successes
                backup_incomplete
                backup_failed
                backup_restores
                backup_billable_space_gb
                backup_year
                backup_month
                parent_configuration_id
                active_flag
                mobile_guid
                display_vendor_flag
                company_location_id
                show_remote_flag
                show_automate_flag
                needs_renewal_flag
              ])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      raise ArgumentError, 'The input argument (attributes) must be a hash in `ConnectWise::CompanyConfiguration` initialize method' unless attributes.is_a?(Hash)

      # check to see if the attribute exists and convert string to symbol for hash key
      acceptable_attribute_map = self.class.acceptable_attribute_map
      attributes = attributes.each_with_object({}) do |(k, v), h|
        raise ArgumentError, "`#{k}` is not a valid attribute in `ConnectWise::CompanyConfiguration`. Please check the name to make sure it's valid. List of attributes: " + acceptable_attribute_map.keys.inspect unless acceptable_attribute_map.key?(k.to_sym)

        h[k.to_sym] = v
      end

      self.name = (attributes[:name] if attributes.key?(:name))

      self.type = (attributes[:type] if attributes.key?(:type))

      self.company = (attributes[:company] if attributes.key?(:company))

      self.id = attributes[:id] if attributes.key?(:id)

      self.status = attributes[:status] if attributes.key?(:status)

      self.contact = attributes[:contact] if attributes.key?(:contact)

      self.site = attributes[:site] if attributes.key?(:site)

      self.location_id = attributes[:location_id] if attributes.key?(:location_id)

      self.location = attributes[:location] if attributes.key?(:location)

      self.business_unit_id = attributes[:business_unit_id] if attributes.key?(:business_unit_id)

      self.department = attributes[:department] if attributes.key?(:department)

      self.device_identifier = attributes[:device_identifier] if attributes.key?(:device_identifier)

      self.serial_number = attributes[:serial_number] if attributes.key?(:serial_number)

      self.model_number = attributes[:model_number] if attributes.key?(:model_number)

      self.tag_number = attributes[:tag_number] if attributes.key?(:tag_number)

      self.purchase_date = attributes[:purchase_date] if attributes.key?(:purchase_date)

      self.installation_date = attributes[:installation_date] if attributes.key?(:installation_date)

      self.installed_by = attributes[:installed_by] if attributes.key?(:installed_by)

      self.warranty_expiration_date = attributes[:warranty_expiration_date] if attributes.key?(:warranty_expiration_date)

      self.vendor_notes = attributes[:vendor_notes] if attributes.key?(:vendor_notes)

      self.notes = attributes[:notes] if attributes.key?(:notes)

      self.mac_address = attributes[:mac_address] if attributes.key?(:mac_address)

      self.last_login_name = attributes[:last_login_name] if attributes.key?(:last_login_name)

      self.bill_flag = attributes[:bill_flag] if attributes.key?(:bill_flag)

      self.backup_successes = attributes[:backup_successes] if attributes.key?(:backup_successes)

      self.backup_incomplete = attributes[:backup_incomplete] if attributes.key?(:backup_incomplete)

      self.backup_failed = attributes[:backup_failed] if attributes.key?(:backup_failed)

      self.backup_restores = attributes[:backup_restores] if attributes.key?(:backup_restores)

      self.last_backup_date = attributes[:last_backup_date] if attributes.key?(:last_backup_date)

      self.backup_server_name = attributes[:backup_server_name] if attributes.key?(:backup_server_name)

      self.backup_billable_space_gb = attributes[:backup_billable_space_gb] if attributes.key?(:backup_billable_space_gb)

      self.backup_protected_device_list = attributes[:backup_protected_device_list] if attributes.key?(:backup_protected_device_list)

      self.backup_year = attributes[:backup_year] if attributes.key?(:backup_year)

      self.backup_month = attributes[:backup_month] if attributes.key?(:backup_month)

      self.ip_address = attributes[:ip_address] if attributes.key?(:ip_address)

      self.default_gateway = attributes[:default_gateway] if attributes.key?(:default_gateway)

      self.os_type = attributes[:os_type] if attributes.key?(:os_type)

      self.os_info = attributes[:os_info] if attributes.key?(:os_info)

      self.cpu_speed = attributes[:cpu_speed] if attributes.key?(:cpu_speed)

      self.ram = attributes[:ram] if attributes.key?(:ram)

      self.local_hard_drives = attributes[:local_hard_drives] if attributes.key?(:local_hard_drives)

      self.parent_configuration_id = attributes[:parent_configuration_id] if attributes.key?(:parent_configuration_id)

      self.vendor = attributes[:vendor] if attributes.key?(:vendor)

      self.manufacturer = attributes[:manufacturer] if attributes.key?(:manufacturer)

      if attributes.key?(:questions) && (value = attributes[:questions]).is_a?(Array)
        self.questions = value
      end

      self.active_flag = attributes[:active_flag] if attributes.key?(:active_flag)

      self.management_link = attributes[:management_link] if attributes.key?(:management_link)

      self.remote_link = attributes[:remote_link] if attributes.key?(:remote_link)

      self.sla = attributes[:sla] if attributes.key?(:sla)

      self.mobile_guid = attributes[:mobile_guid] if attributes.key?(:mobile_guid)

      self.display_vendor_flag = attributes[:display_vendor_flag] if attributes.key?(:display_vendor_flag)

      self.company_location_id = attributes[:company_location_id] if attributes.key?(:company_location_id)

      self.show_remote_flag = attributes[:show_remote_flag] if attributes.key?(:show_remote_flag)

      self.show_automate_flag = attributes[:show_automate_flag] if attributes.key?(:show_automate_flag)

      self.needs_renewal_flag = attributes[:needs_renewal_flag] if attributes.key?(:needs_renewal_flag)

      self.manufacturer_part_number = attributes[:manufacturer_part_number] if attributes.key?(:manufacturer_part_number)

      if attributes.key?(:_info) && (value = attributes[:_info]).is_a?(Hash)
        self._info = value
      end

      return unless attributes.key?(:custom_fields)

      if (value = attributes[:custom_fields]).is_a?(Array)
        self.custom_fields = value
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      warn '[DEPRECATED] the `list_invalid_properties` method is obsolete'
      invalid_properties = []
      invalid_properties.push('invalid value for "name", name cannot be nil.') if @name.nil?

      invalid_properties.push('invalid value for "type", type cannot be nil.') if @type.nil?

      invalid_properties.push('invalid value for "company", company cannot be nil.') if @company.nil?

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      warn '[DEPRECATED] the `valid?` method is obsolete'
      return false if @name.nil?
      return false if @type.nil?
      return false if @company.nil?

      true
    end

    # Custom attribute writer method with validation
    # @param [Object] name Value to be assigned
    def name=(name)
      raise ArgumentError, 'name cannot be nil' if name.nil?

      @name = name
    end

    # Custom attribute writer method with validation
    # @param [Object] type Value to be assigned
    def type=(type)
      raise ArgumentError, 'type cannot be nil' if type.nil?

      @type = type
    end

    # Custom attribute writer method with validation
    # @param [Object] company Value to be assigned
    def company=(company)
      raise ArgumentError, 'company cannot be nil' if company.nil?

      @company = company
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        name == other.name &&
        type == other.type &&
        company == other.company &&
        id == other.id &&
        status == other.status &&
        contact == other.contact &&
        site == other.site &&
        location_id == other.location_id &&
        location == other.location &&
        business_unit_id == other.business_unit_id &&
        department == other.department &&
        device_identifier == other.device_identifier &&
        serial_number == other.serial_number &&
        model_number == other.model_number &&
        tag_number == other.tag_number &&
        purchase_date == other.purchase_date &&
        installation_date == other.installation_date &&
        installed_by == other.installed_by &&
        warranty_expiration_date == other.warranty_expiration_date &&
        vendor_notes == other.vendor_notes &&
        notes == other.notes &&
        mac_address == other.mac_address &&
        last_login_name == other.last_login_name &&
        bill_flag == other.bill_flag &&
        backup_successes == other.backup_successes &&
        backup_incomplete == other.backup_incomplete &&
        backup_failed == other.backup_failed &&
        backup_restores == other.backup_restores &&
        last_backup_date == other.last_backup_date &&
        backup_server_name == other.backup_server_name &&
        backup_billable_space_gb == other.backup_billable_space_gb &&
        backup_protected_device_list == other.backup_protected_device_list &&
        backup_year == other.backup_year &&
        backup_month == other.backup_month &&
        ip_address == other.ip_address &&
        default_gateway == other.default_gateway &&
        os_type == other.os_type &&
        os_info == other.os_info &&
        cpu_speed == other.cpu_speed &&
        ram == other.ram &&
        local_hard_drives == other.local_hard_drives &&
        parent_configuration_id == other.parent_configuration_id &&
        vendor == other.vendor &&
        manufacturer == other.manufacturer &&
        questions == other.questions &&
        active_flag == other.active_flag &&
        management_link == other.management_link &&
        remote_link == other.remote_link &&
        sla == other.sla &&
        mobile_guid == other.mobile_guid &&
        display_vendor_flag == other.display_vendor_flag &&
        company_location_id == other.company_location_id &&
        show_remote_flag == other.show_remote_flag &&
        show_automate_flag == other.show_automate_flag &&
        needs_renewal_flag == other.needs_renewal_flag &&
        manufacturer_part_number == other.manufacturer_part_number &&
        _info == other._info &&
        custom_fields == other.custom_fields
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(other)
      self == other
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [name, type, company, id, status, contact, site, location_id, location, business_unit_id, department, device_identifier, serial_number, model_number, tag_number, purchase_date, installation_date, installed_by, warranty_expiration_date, vendor_notes, notes, mac_address, last_login_name, bill_flag, backup_successes, backup_incomplete, backup_failed, backup_restores, last_backup_date, backup_server_name, backup_billable_space_gb, backup_protected_device_list, backup_year, backup_month, ip_address, default_gateway, os_type, os_info, cpu_speed, ram, local_hard_drives, parent_configuration_id, vendor, manufacturer, questions, active_flag, management_link, remote_link, sla, mobile_guid, display_vendor_flag, company_location_id, show_remote_flag, show_automate_flag, needs_renewal_flag, manufacturer_part_number, _info, custom_fields].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      attributes = attributes.transform_keys(&:to_sym)
      transformed_hash = {}
      openapi_types.each_pair do |key, type|
        if attributes.key?(attribute_map[key]) && attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = nil
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          transformed_hash["#{key}"] = attributes[attribute_map[key]].map { |v| _deserialize(::Regexp.last_match(1), v) } if attributes[attribute_map[key]].is_a?(Array)
        elsif !attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = _deserialize(type, attributes[attribute_map[key]])
        end
      end
      new(transformed_hash)
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def self._deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = ConnectWise.const_get(type)
        klass.respond_to?(:openapi_any_of) || klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end

# #Connectwise Manage Public Endpoints
#
# No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
#
# The version of the OpenAPI document: 2025.1
#
# Generated by: https://openapi-generator.tech
# Generator version: 7.12.0
#

require 'date'
require 'time'

module ConnectWise
  class MyMember
    attr_accessor :id, :identifier, :first_name, :middle_initial, :last_name, :title, :report_card,
                  :disable_online_flag, :enable_mobile_flag, :type, :employee_identifer, :vendor_number, :notes, :time_zone, :country, :service_board_team_ids, :enable_mobile_gps_flag, :inactive_date, :inactive_flag, :last_login, :photo, :toast_notification_flag, :office_email, :office_phone, :office_extension, :mobile_email, :mobile_phone, :mobile_extension, :home_email, :home_phone, :home_extension, :default_email, :default_phone, :security_role, :admin_flag, :structure_level, :security_location, :default_location, :default_department, :reports_to, :restrict_location_flag, :restrict_department_flag, :work_role, :work_type, :time_approver, :expense_approver, :billable_forecast, :daily_capacity, :hourly_cost, :hourly_rate, :include_in_utilization_reporting_flag, :require_expense_entry_flag, :require_time_sheet_entry_flag, :require_start_and_end_time_on_time_entry_flag, :allow_in_cell_entry_on_time_sheet, :enter_time_against_company_flag, :allow_expenses_entered_against_companies_flag, :time_reminder_email_flag, :days_tolerance, :minimum_hours, :time_sheet_start_date, :hire_date, :service_default_location, :service_default_department, :service_default_board, :restrict_service_default_location_flag, :restrict_service_default_department_flag, :excluded_service_board_ids, :project_default_location, :project_default_department, :project_default_board, :restrict_project_default_location_flag, :restrict_project_default_department_flag, :excluded_project_board_ids, :schedule_default_location, :schedule_default_department, :schedule_capacity, :service_location, :restrict_schedule_flag, :hide_member_in_dispatch_portal_flag, :calendar, :sales_default_location, :restrict_default_sales_territory_flag, :warehouse, :warehouse_bin, :restrict_default_warehouse_flag, :restrict_default_warehouse_bin_flag, :mapi_name, :calendar_sync_integration_flag, :enable_ldap_authentication_flag, :ldap_configuration, :ldap_user_name, :company_activity_tab_format, :invoice_time_tab_format, :invoice_screen_default_tab_format, :invoicing_display_options, :agreement_invoicing_display_options, :corelytics_username, :corelytics_password, :authentication_service_type, :timebased_one_time_password_activated, :directional_sync, :sso_session_flag, :sso_client_id, :_info

    # ConditionallyRequired. API Member will get random password generated
    attr_accessor :password

    # F = Full Member, A = API Member, C = StreamlineIT Member, X = Subcontractor Member
    attr_accessor :license_class

    class EnumAttributeValidator
      attr_reader :datatype, :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        id: :id,
        identifier: :identifier,
        password: :password,
        first_name: :firstName,
        middle_initial: :middleInitial,
        last_name: :lastName,
        title: :title,
        report_card: :reportCard,
        license_class: :licenseClass,
        disable_online_flag: :disableOnlineFlag,
        enable_mobile_flag: :enableMobileFlag,
        type: :type,
        employee_identifer: :employeeIdentifer,
        vendor_number: :vendorNumber,
        notes: :notes,
        time_zone: :timeZone,
        country: :country,
        service_board_team_ids: :serviceBoardTeamIds,
        enable_mobile_gps_flag: :enableMobileGpsFlag,
        inactive_date: :inactiveDate,
        inactive_flag: :inactiveFlag,
        last_login: :lastLogin,
        photo: :photo,
        toast_notification_flag: :toastNotificationFlag,
        office_email: :officeEmail,
        office_phone: :officePhone,
        office_extension: :officeExtension,
        mobile_email: :mobileEmail,
        mobile_phone: :mobilePhone,
        mobile_extension: :mobileExtension,
        home_email: :homeEmail,
        home_phone: :homePhone,
        home_extension: :homeExtension,
        default_email: :defaultEmail,
        default_phone: :defaultPhone,
        security_role: :securityRole,
        admin_flag: :adminFlag,
        structure_level: :structureLevel,
        security_location: :securityLocation,
        default_location: :defaultLocation,
        default_department: :defaultDepartment,
        reports_to: :reportsTo,
        restrict_location_flag: :restrictLocationFlag,
        restrict_department_flag: :restrictDepartmentFlag,
        work_role: :workRole,
        work_type: :workType,
        time_approver: :timeApprover,
        expense_approver: :expenseApprover,
        billable_forecast: :billableForecast,
        daily_capacity: :dailyCapacity,
        hourly_cost: :hourlyCost,
        hourly_rate: :hourlyRate,
        include_in_utilization_reporting_flag: :includeInUtilizationReportingFlag,
        require_expense_entry_flag: :requireExpenseEntryFlag,
        require_time_sheet_entry_flag: :requireTimeSheetEntryFlag,
        require_start_and_end_time_on_time_entry_flag: :requireStartAndEndTimeOnTimeEntryFlag,
        allow_in_cell_entry_on_time_sheet: :allowInCellEntryOnTimeSheet,
        enter_time_against_company_flag: :enterTimeAgainstCompanyFlag,
        allow_expenses_entered_against_companies_flag: :allowExpensesEnteredAgainstCompaniesFlag,
        time_reminder_email_flag: :timeReminderEmailFlag,
        days_tolerance: :daysTolerance,
        minimum_hours: :minimumHours,
        time_sheet_start_date: :timeSheetStartDate,
        hire_date: :hireDate,
        service_default_location: :serviceDefaultLocation,
        service_default_department: :serviceDefaultDepartment,
        service_default_board: :serviceDefaultBoard,
        restrict_service_default_location_flag: :restrictServiceDefaultLocationFlag,
        restrict_service_default_department_flag: :restrictServiceDefaultDepartmentFlag,
        excluded_service_board_ids: :excludedServiceBoardIds,
        project_default_location: :projectDefaultLocation,
        project_default_department: :projectDefaultDepartment,
        project_default_board: :projectDefaultBoard,
        restrict_project_default_location_flag: :restrictProjectDefaultLocationFlag,
        restrict_project_default_department_flag: :restrictProjectDefaultDepartmentFlag,
        excluded_project_board_ids: :excludedProjectBoardIds,
        schedule_default_location: :scheduleDefaultLocation,
        schedule_default_department: :scheduleDefaultDepartment,
        schedule_capacity: :scheduleCapacity,
        service_location: :serviceLocation,
        restrict_schedule_flag: :restrictScheduleFlag,
        hide_member_in_dispatch_portal_flag: :hideMemberInDispatchPortalFlag,
        calendar: :calendar,
        sales_default_location: :salesDefaultLocation,
        restrict_default_sales_territory_flag: :restrictDefaultSalesTerritoryFlag,
        warehouse: :warehouse,
        warehouse_bin: :warehouseBin,
        restrict_default_warehouse_flag: :restrictDefaultWarehouseFlag,
        restrict_default_warehouse_bin_flag: :restrictDefaultWarehouseBinFlag,
        mapi_name: :mapiName,
        calendar_sync_integration_flag: :calendarSyncIntegrationFlag,
        enable_ldap_authentication_flag: :enableLdapAuthenticationFlag,
        ldap_configuration: :ldapConfiguration,
        ldap_user_name: :ldapUserName,
        company_activity_tab_format: :companyActivityTabFormat,
        invoice_time_tab_format: :invoiceTimeTabFormat,
        invoice_screen_default_tab_format: :invoiceScreenDefaultTabFormat,
        invoicing_display_options: :invoicingDisplayOptions,
        agreement_invoicing_display_options: :agreementInvoicingDisplayOptions,
        corelytics_username: :corelyticsUsername,
        corelytics_password: :corelyticsPassword,
        authentication_service_type: :authenticationServiceType,
        timebased_one_time_password_activated: :timebasedOneTimePasswordActivated,
        directional_sync: :directionalSync,
        sso_session_flag: :ssoSessionFlag,
        sso_client_id: :ssoClientId,
        _info: :_info
      }
    end

    # Returns attribute mapping this model knows about
    def self.acceptable_attribute_map
      attribute_map
    end

    # Returns all the JSON keys this model knows about
    def self.acceptable_attributes
      acceptable_attribute_map.values
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        id: :Integer,
        identifier: :String,
        password: :String,
        first_name: :String,
        middle_initial: :String,
        last_name: :String,
        title: :String,
        report_card: :ReportCardReference,
        license_class: :String,
        disable_online_flag: :Boolean,
        enable_mobile_flag: :Boolean,
        type: :MemberTypeReference,
        employee_identifer: :String,
        vendor_number: :String,
        notes: :String,
        time_zone: :TimeZoneSetupReference,
        country: :CountryReference,
        service_board_team_ids: :'Array<Integer>',
        enable_mobile_gps_flag: :Boolean,
        inactive_date: :String,
        inactive_flag: :Boolean,
        last_login: :String,
        photo: :DocumentReference,
        toast_notification_flag: :Boolean,
        office_email: :String,
        office_phone: :String,
        office_extension: :String,
        mobile_email: :String,
        mobile_phone: :String,
        mobile_extension: :String,
        home_email: :String,
        home_phone: :String,
        home_extension: :String,
        default_email: :String,
        default_phone: :String,
        security_role: :SecurityRoleReference,
        admin_flag: :Boolean,
        structure_level: :StructureReference,
        security_location: :SystemLocationReference,
        default_location: :SystemLocationReference,
        default_department: :SystemDepartmentReference,
        reports_to: :MemberReference,
        restrict_location_flag: :Boolean,
        restrict_department_flag: :Boolean,
        work_role: :WorkRoleReference,
        work_type: :WorkTypeReference,
        time_approver: :MemberReference,
        expense_approver: :MemberReference,
        billable_forecast: :Float,
        daily_capacity: :Float,
        hourly_cost: :Float,
        hourly_rate: :Float,
        include_in_utilization_reporting_flag: :Boolean,
        require_expense_entry_flag: :Boolean,
        require_time_sheet_entry_flag: :Boolean,
        require_start_and_end_time_on_time_entry_flag: :Boolean,
        allow_in_cell_entry_on_time_sheet: :Boolean,
        enter_time_against_company_flag: :Boolean,
        allow_expenses_entered_against_companies_flag: :Boolean,
        time_reminder_email_flag: :Boolean,
        days_tolerance: :Integer,
        minimum_hours: :Float,
        time_sheet_start_date: :String,
        hire_date: :String,
        service_default_location: :SystemLocationReference,
        service_default_department: :SystemDepartmentReference,
        service_default_board: :BoardReference,
        restrict_service_default_location_flag: :Boolean,
        restrict_service_default_department_flag: :Boolean,
        excluded_service_board_ids: :'Array<Integer>',
        project_default_location: :SystemLocationReference,
        project_default_department: :SystemDepartmentReference,
        project_default_board: :ProjectBoardReference,
        restrict_project_default_location_flag: :Boolean,
        restrict_project_default_department_flag: :Boolean,
        excluded_project_board_ids: :'Array<Integer>',
        schedule_default_location: :SystemLocationReference,
        schedule_default_department: :SystemDepartmentReference,
        schedule_capacity: :Float,
        service_location: :ServiceLocationReference,
        restrict_schedule_flag: :Boolean,
        hide_member_in_dispatch_portal_flag: :Boolean,
        calendar: :CalendarReference,
        sales_default_location: :SystemLocationReference,
        restrict_default_sales_territory_flag: :Boolean,
        warehouse: :WarehouseReference,
        warehouse_bin: :WarehouseBinReference,
        restrict_default_warehouse_flag: :Boolean,
        restrict_default_warehouse_bin_flag: :Boolean,
        mapi_name: :String,
        calendar_sync_integration_flag: :Boolean,
        enable_ldap_authentication_flag: :Boolean,
        ldap_configuration: :LdapConfigurationReference,
        ldap_user_name: :String,
        company_activity_tab_format: :String,
        invoice_time_tab_format: :String,
        invoice_screen_default_tab_format: :String,
        invoicing_display_options: :String,
        agreement_invoicing_display_options: :String,
        corelytics_username: :String,
        corelytics_password: :String,
        authentication_service_type: :String,
        timebased_one_time_password_activated: :Boolean,
        directional_sync: :DirectionalSyncReference,
        sso_session_flag: :Boolean,
        sso_client_id: :String,
        _info: :'Hash<String, String>'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new(%i[
                license_class
                disable_online_flag
                enable_mobile_flag
                enable_mobile_gps_flag
                inactive_flag
                toast_notification_flag
                default_email
                default_phone
                admin_flag
                restrict_location_flag
                restrict_department_flag
                billable_forecast
                daily_capacity
                hourly_cost
                hourly_rate
                include_in_utilization_reporting_flag
                require_expense_entry_flag
                require_time_sheet_entry_flag
                require_start_and_end_time_on_time_entry_flag
                allow_in_cell_entry_on_time_sheet
                enter_time_against_company_flag
                allow_expenses_entered_against_companies_flag
                time_reminder_email_flag
                days_tolerance
                minimum_hours
                restrict_service_default_location_flag
                restrict_service_default_department_flag
                restrict_project_default_location_flag
                restrict_project_default_department_flag
                schedule_capacity
                restrict_schedule_flag
                hide_member_in_dispatch_portal_flag
                restrict_default_sales_territory_flag
                restrict_default_warehouse_flag
                restrict_default_warehouse_bin_flag
                calendar_sync_integration_flag
                enable_ldap_authentication_flag
                company_activity_tab_format
                invoice_time_tab_format
                invoice_screen_default_tab_format
                invoicing_display_options
                agreement_invoicing_display_options
                authentication_service_type
                timebased_one_time_password_activated
                sso_session_flag
              ])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      unless attributes.is_a?(Hash)
        raise ArgumentError,
              'The input argument (attributes) must be a hash in `ConnectWise::MyMember` initialize method'
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      acceptable_attribute_map = self.class.acceptable_attribute_map
      attributes = attributes.each_with_object({}) do |(k, v), h|
        unless acceptable_attribute_map.key?(k.to_sym)
          raise ArgumentError,
                "`#{k}` is not a valid attribute in `ConnectWise::MyMember`. Please check the name to make sure it's valid. List of attributes: " + acceptable_attribute_map.keys.inspect
        end

        h[k.to_sym] = v
      end

      self.id = attributes[:id] if attributes.key?(:id)

      self.identifier = attributes[:identifier] if attributes.key?(:identifier)

      self.password = attributes[:password] if attributes.key?(:password)

      self.first_name = attributes[:first_name] if attributes.key?(:first_name)

      self.middle_initial = attributes[:middle_initial] if attributes.key?(:middle_initial)

      self.last_name = attributes[:last_name] if attributes.key?(:last_name)

      self.title = attributes[:title] if attributes.key?(:title)

      self.report_card = attributes[:report_card] if attributes.key?(:report_card)

      self.license_class = attributes[:license_class] if attributes.key?(:license_class)

      self.disable_online_flag = attributes[:disable_online_flag] if attributes.key?(:disable_online_flag)

      self.enable_mobile_flag = attributes[:enable_mobile_flag] if attributes.key?(:enable_mobile_flag)

      self.type = attributes[:type] if attributes.key?(:type)

      self.employee_identifer = attributes[:employee_identifer] if attributes.key?(:employee_identifer)

      self.vendor_number = attributes[:vendor_number] if attributes.key?(:vendor_number)

      self.notes = attributes[:notes] if attributes.key?(:notes)

      self.time_zone = attributes[:time_zone] if attributes.key?(:time_zone)

      self.country = attributes[:country] if attributes.key?(:country)

      if attributes.key?(:service_board_team_ids) && (value = attributes[:service_board_team_ids]).is_a?(Array)
        self.service_board_team_ids = value
      end

      self.enable_mobile_gps_flag = attributes[:enable_mobile_gps_flag] if attributes.key?(:enable_mobile_gps_flag)

      self.inactive_date = attributes[:inactive_date] if attributes.key?(:inactive_date)

      self.inactive_flag = attributes[:inactive_flag] if attributes.key?(:inactive_flag)

      self.last_login = attributes[:last_login] if attributes.key?(:last_login)

      self.photo = attributes[:photo] if attributes.key?(:photo)

      self.toast_notification_flag = attributes[:toast_notification_flag] if attributes.key?(:toast_notification_flag)

      self.office_email = attributes[:office_email] if attributes.key?(:office_email)

      self.office_phone = attributes[:office_phone] if attributes.key?(:office_phone)

      self.office_extension = attributes[:office_extension] if attributes.key?(:office_extension)

      self.mobile_email = attributes[:mobile_email] if attributes.key?(:mobile_email)

      self.mobile_phone = attributes[:mobile_phone] if attributes.key?(:mobile_phone)

      self.mobile_extension = attributes[:mobile_extension] if attributes.key?(:mobile_extension)

      self.home_email = attributes[:home_email] if attributes.key?(:home_email)

      self.home_phone = attributes[:home_phone] if attributes.key?(:home_phone)

      self.home_extension = attributes[:home_extension] if attributes.key?(:home_extension)

      self.default_email = attributes[:default_email] if attributes.key?(:default_email)

      self.default_phone = attributes[:default_phone] if attributes.key?(:default_phone)

      self.security_role = attributes[:security_role] if attributes.key?(:security_role)

      self.admin_flag = attributes[:admin_flag] if attributes.key?(:admin_flag)

      self.structure_level = attributes[:structure_level] if attributes.key?(:structure_level)

      self.security_location = attributes[:security_location] if attributes.key?(:security_location)

      self.default_location = attributes[:default_location] if attributes.key?(:default_location)

      self.default_department = attributes[:default_department] if attributes.key?(:default_department)

      self.reports_to = attributes[:reports_to] if attributes.key?(:reports_to)

      self.restrict_location_flag = attributes[:restrict_location_flag] if attributes.key?(:restrict_location_flag)

      if attributes.key?(:restrict_department_flag)
        self.restrict_department_flag = attributes[:restrict_department_flag]
      end

      self.work_role = attributes[:work_role] if attributes.key?(:work_role)

      self.work_type = attributes[:work_type] if attributes.key?(:work_type)

      self.time_approver = attributes[:time_approver] if attributes.key?(:time_approver)

      self.expense_approver = attributes[:expense_approver] if attributes.key?(:expense_approver)

      self.billable_forecast = attributes[:billable_forecast] if attributes.key?(:billable_forecast)

      self.daily_capacity = attributes[:daily_capacity] if attributes.key?(:daily_capacity)

      self.hourly_cost = attributes[:hourly_cost] if attributes.key?(:hourly_cost)

      self.hourly_rate = attributes[:hourly_rate] if attributes.key?(:hourly_rate)

      if attributes.key?(:include_in_utilization_reporting_flag)
        self.include_in_utilization_reporting_flag = attributes[:include_in_utilization_reporting_flag]
      end

      if attributes.key?(:require_expense_entry_flag)
        self.require_expense_entry_flag = attributes[:require_expense_entry_flag]
      end

      if attributes.key?(:require_time_sheet_entry_flag)
        self.require_time_sheet_entry_flag = attributes[:require_time_sheet_entry_flag]
      end

      if attributes.key?(:require_start_and_end_time_on_time_entry_flag)
        self.require_start_and_end_time_on_time_entry_flag = attributes[:require_start_and_end_time_on_time_entry_flag]
      end

      if attributes.key?(:allow_in_cell_entry_on_time_sheet)
        self.allow_in_cell_entry_on_time_sheet = attributes[:allow_in_cell_entry_on_time_sheet]
      end

      if attributes.key?(:enter_time_against_company_flag)
        self.enter_time_against_company_flag = attributes[:enter_time_against_company_flag]
      end

      if attributes.key?(:allow_expenses_entered_against_companies_flag)
        self.allow_expenses_entered_against_companies_flag = attributes[:allow_expenses_entered_against_companies_flag]
      end

      if attributes.key?(:time_reminder_email_flag)
        self.time_reminder_email_flag = attributes[:time_reminder_email_flag]
      end

      self.days_tolerance = attributes[:days_tolerance] if attributes.key?(:days_tolerance)

      self.minimum_hours = attributes[:minimum_hours] if attributes.key?(:minimum_hours)

      self.time_sheet_start_date = attributes[:time_sheet_start_date] if attributes.key?(:time_sheet_start_date)

      self.hire_date = attributes[:hire_date] if attributes.key?(:hire_date)

      if attributes.key?(:service_default_location)
        self.service_default_location = attributes[:service_default_location]
      end

      if attributes.key?(:service_default_department)
        self.service_default_department = attributes[:service_default_department]
      end

      self.service_default_board = attributes[:service_default_board] if attributes.key?(:service_default_board)

      if attributes.key?(:restrict_service_default_location_flag)
        self.restrict_service_default_location_flag = attributes[:restrict_service_default_location_flag]
      end

      if attributes.key?(:restrict_service_default_department_flag)
        self.restrict_service_default_department_flag = attributes[:restrict_service_default_department_flag]
      end

      if attributes.key?(:excluded_service_board_ids) && (value = attributes[:excluded_service_board_ids]).is_a?(Array)
        self.excluded_service_board_ids = value
      end

      if attributes.key?(:project_default_location)
        self.project_default_location = attributes[:project_default_location]
      end

      if attributes.key?(:project_default_department)
        self.project_default_department = attributes[:project_default_department]
      end

      self.project_default_board = attributes[:project_default_board] if attributes.key?(:project_default_board)

      if attributes.key?(:restrict_project_default_location_flag)
        self.restrict_project_default_location_flag = attributes[:restrict_project_default_location_flag]
      end

      if attributes.key?(:restrict_project_default_department_flag)
        self.restrict_project_default_department_flag = attributes[:restrict_project_default_department_flag]
      end

      if attributes.key?(:excluded_project_board_ids) && (value = attributes[:excluded_project_board_ids]).is_a?(Array)
        self.excluded_project_board_ids = value
      end

      if attributes.key?(:schedule_default_location)
        self.schedule_default_location = attributes[:schedule_default_location]
      end

      if attributes.key?(:schedule_default_department)
        self.schedule_default_department = attributes[:schedule_default_department]
      end

      self.schedule_capacity = attributes[:schedule_capacity] if attributes.key?(:schedule_capacity)

      self.service_location = attributes[:service_location] if attributes.key?(:service_location)

      self.restrict_schedule_flag = attributes[:restrict_schedule_flag] if attributes.key?(:restrict_schedule_flag)

      if attributes.key?(:hide_member_in_dispatch_portal_flag)
        self.hide_member_in_dispatch_portal_flag = attributes[:hide_member_in_dispatch_portal_flag]
      end

      self.calendar = attributes[:calendar] if attributes.key?(:calendar)

      self.sales_default_location = attributes[:sales_default_location] if attributes.key?(:sales_default_location)

      if attributes.key?(:restrict_default_sales_territory_flag)
        self.restrict_default_sales_territory_flag = attributes[:restrict_default_sales_territory_flag]
      end

      self.warehouse = attributes[:warehouse] if attributes.key?(:warehouse)

      self.warehouse_bin = attributes[:warehouse_bin] if attributes.key?(:warehouse_bin)

      if attributes.key?(:restrict_default_warehouse_flag)
        self.restrict_default_warehouse_flag = attributes[:restrict_default_warehouse_flag]
      end

      if attributes.key?(:restrict_default_warehouse_bin_flag)
        self.restrict_default_warehouse_bin_flag = attributes[:restrict_default_warehouse_bin_flag]
      end

      self.mapi_name = attributes[:mapi_name] if attributes.key?(:mapi_name)

      if attributes.key?(:calendar_sync_integration_flag)
        self.calendar_sync_integration_flag = attributes[:calendar_sync_integration_flag]
      end

      if attributes.key?(:enable_ldap_authentication_flag)
        self.enable_ldap_authentication_flag = attributes[:enable_ldap_authentication_flag]
      end

      self.ldap_configuration = attributes[:ldap_configuration] if attributes.key?(:ldap_configuration)

      self.ldap_user_name = attributes[:ldap_user_name] if attributes.key?(:ldap_user_name)

      if attributes.key?(:company_activity_tab_format)
        self.company_activity_tab_format = attributes[:company_activity_tab_format]
      end

      self.invoice_time_tab_format = attributes[:invoice_time_tab_format] if attributes.key?(:invoice_time_tab_format)

      if attributes.key?(:invoice_screen_default_tab_format)
        self.invoice_screen_default_tab_format = attributes[:invoice_screen_default_tab_format]
      end

      if attributes.key?(:invoicing_display_options)
        self.invoicing_display_options = attributes[:invoicing_display_options]
      end

      if attributes.key?(:agreement_invoicing_display_options)
        self.agreement_invoicing_display_options = attributes[:agreement_invoicing_display_options]
      end

      self.corelytics_username = attributes[:corelytics_username] if attributes.key?(:corelytics_username)

      self.corelytics_password = attributes[:corelytics_password] if attributes.key?(:corelytics_password)

      if attributes.key?(:authentication_service_type)
        self.authentication_service_type = attributes[:authentication_service_type]
      end

      if attributes.key?(:timebased_one_time_password_activated)
        self.timebased_one_time_password_activated = attributes[:timebased_one_time_password_activated]
      end

      self.directional_sync = attributes[:directional_sync] if attributes.key?(:directional_sync)

      self.sso_session_flag = attributes[:sso_session_flag] if attributes.key?(:sso_session_flag)

      self.sso_client_id = attributes[:sso_client_id] if attributes.key?(:sso_client_id)

      return unless attributes.key?(:_info)

      if (value = attributes[:_info]).is_a?(Hash)
        self._info = value
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      warn '[DEPRECATED] the `list_invalid_properties` method is obsolete'
      []
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      warn '[DEPRECATED] the `valid?` method is obsolete'
      license_class_validator = EnumAttributeValidator.new('String', %w[A C F X])
      return false unless license_class_validator.valid?(@license_class)

      default_email_validator = EnumAttributeValidator.new('String', %w[Office Mobile Home])
      return false unless default_email_validator.valid?(@default_email)

      default_phone_validator = EnumAttributeValidator.new('String', %w[Office Mobile Home])
      return false unless default_phone_validator.valid?(@default_phone)

      company_activity_tab_format_validator = EnumAttributeValidator.new('String', %w[SummaryList DetailList])
      return false unless company_activity_tab_format_validator.valid?(@company_activity_tab_format)

      invoice_time_tab_format_validator = EnumAttributeValidator.new('String', %w[SummaryList DetailList])
      return false unless invoice_time_tab_format_validator.valid?(@invoice_time_tab_format)

      invoice_screen_default_tab_format_validator = EnumAttributeValidator.new('String',
                                                                               %w[ShowInvoicingTab
                                                                                  ShowAgreementInvoicingTab])
      return false unless invoice_screen_default_tab_format_validator.valid?(@invoice_screen_default_tab_format)

      invoicing_display_options_validator = EnumAttributeValidator.new('String',
                                                                       %w[RemainOnInvoicingScreen ShowRecentInvoices])
      return false unless invoicing_display_options_validator.valid?(@invoicing_display_options)

      agreement_invoicing_display_options_validator = EnumAttributeValidator.new('String',
                                                                                 %w[RemainOnInvoicingScreen
                                                                                    ShowRecentInvoices])
      return false unless agreement_invoicing_display_options_validator.valid?(@agreement_invoicing_display_options)

      authentication_service_type_validator = EnumAttributeValidator.new('String',
                                                                         %w[AuthAnvil GoogleAuthenticator Email])
      return false unless authentication_service_type_validator.valid?(@authentication_service_type)

      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] license_class Object to be assigned
    def license_class=(license_class)
      validator = EnumAttributeValidator.new('String', %w[A C F X])
      unless validator.valid?(license_class)
        raise ArgumentError, "invalid value for \"license_class\", must be one of #{validator.allowable_values}."
      end

      @license_class = license_class
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] default_email Object to be assigned
    def default_email=(default_email)
      validator = EnumAttributeValidator.new('String', %w[Office Mobile Home])
      unless validator.valid?(default_email)
        raise ArgumentError, "invalid value for \"default_email\", must be one of #{validator.allowable_values}."
      end

      @default_email = default_email
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] default_phone Object to be assigned
    def default_phone=(default_phone)
      validator = EnumAttributeValidator.new('String', %w[Office Mobile Home])
      unless validator.valid?(default_phone)
        raise ArgumentError, "invalid value for \"default_phone\", must be one of #{validator.allowable_values}."
      end

      @default_phone = default_phone
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] company_activity_tab_format Object to be assigned
    def company_activity_tab_format=(company_activity_tab_format)
      validator = EnumAttributeValidator.new('String', %w[SummaryList DetailList])
      unless validator.valid?(company_activity_tab_format)
        raise ArgumentError,
              "invalid value for \"company_activity_tab_format\", must be one of #{validator.allowable_values}."
      end

      @company_activity_tab_format = company_activity_tab_format
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] invoice_time_tab_format Object to be assigned
    def invoice_time_tab_format=(invoice_time_tab_format)
      validator = EnumAttributeValidator.new('String', %w[SummaryList DetailList])
      unless validator.valid?(invoice_time_tab_format)
        raise ArgumentError,
              "invalid value for \"invoice_time_tab_format\", must be one of #{validator.allowable_values}."
      end

      @invoice_time_tab_format = invoice_time_tab_format
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] invoice_screen_default_tab_format Object to be assigned
    def invoice_screen_default_tab_format=(invoice_screen_default_tab_format)
      validator = EnumAttributeValidator.new('String', %w[ShowInvoicingTab ShowAgreementInvoicingTab])
      unless validator.valid?(invoice_screen_default_tab_format)
        raise ArgumentError,
              "invalid value for \"invoice_screen_default_tab_format\", must be one of #{validator.allowable_values}."
      end

      @invoice_screen_default_tab_format = invoice_screen_default_tab_format
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] invoicing_display_options Object to be assigned
    def invoicing_display_options=(invoicing_display_options)
      validator = EnumAttributeValidator.new('String', %w[RemainOnInvoicingScreen ShowRecentInvoices])
      unless validator.valid?(invoicing_display_options)
        raise ArgumentError,
              "invalid value for \"invoicing_display_options\", must be one of #{validator.allowable_values}."
      end

      @invoicing_display_options = invoicing_display_options
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] agreement_invoicing_display_options Object to be assigned
    def agreement_invoicing_display_options=(agreement_invoicing_display_options)
      validator = EnumAttributeValidator.new('String', %w[RemainOnInvoicingScreen ShowRecentInvoices])
      unless validator.valid?(agreement_invoicing_display_options)
        raise ArgumentError,
              "invalid value for \"agreement_invoicing_display_options\", must be one of #{validator.allowable_values}."
      end

      @agreement_invoicing_display_options = agreement_invoicing_display_options
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] authentication_service_type Object to be assigned
    def authentication_service_type=(authentication_service_type)
      validator = EnumAttributeValidator.new('String', %w[AuthAnvil GoogleAuthenticator Email])
      unless validator.valid?(authentication_service_type)
        raise ArgumentError,
              "invalid value for \"authentication_service_type\", must be one of #{validator.allowable_values}."
      end

      @authentication_service_type = authentication_service_type
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        id == other.id &&
        identifier == other.identifier &&
        password == other.password &&
        first_name == other.first_name &&
        middle_initial == other.middle_initial &&
        last_name == other.last_name &&
        title == other.title &&
        report_card == other.report_card &&
        license_class == other.license_class &&
        disable_online_flag == other.disable_online_flag &&
        enable_mobile_flag == other.enable_mobile_flag &&
        type == other.type &&
        employee_identifer == other.employee_identifer &&
        vendor_number == other.vendor_number &&
        notes == other.notes &&
        time_zone == other.time_zone &&
        country == other.country &&
        service_board_team_ids == other.service_board_team_ids &&
        enable_mobile_gps_flag == other.enable_mobile_gps_flag &&
        inactive_date == other.inactive_date &&
        inactive_flag == other.inactive_flag &&
        last_login == other.last_login &&
        photo == other.photo &&
        toast_notification_flag == other.toast_notification_flag &&
        office_email == other.office_email &&
        office_phone == other.office_phone &&
        office_extension == other.office_extension &&
        mobile_email == other.mobile_email &&
        mobile_phone == other.mobile_phone &&
        mobile_extension == other.mobile_extension &&
        home_email == other.home_email &&
        home_phone == other.home_phone &&
        home_extension == other.home_extension &&
        default_email == other.default_email &&
        default_phone == other.default_phone &&
        security_role == other.security_role &&
        admin_flag == other.admin_flag &&
        structure_level == other.structure_level &&
        security_location == other.security_location &&
        default_location == other.default_location &&
        default_department == other.default_department &&
        reports_to == other.reports_to &&
        restrict_location_flag == other.restrict_location_flag &&
        restrict_department_flag == other.restrict_department_flag &&
        work_role == other.work_role &&
        work_type == other.work_type &&
        time_approver == other.time_approver &&
        expense_approver == other.expense_approver &&
        billable_forecast == other.billable_forecast &&
        daily_capacity == other.daily_capacity &&
        hourly_cost == other.hourly_cost &&
        hourly_rate == other.hourly_rate &&
        include_in_utilization_reporting_flag == other.include_in_utilization_reporting_flag &&
        require_expense_entry_flag == other.require_expense_entry_flag &&
        require_time_sheet_entry_flag == other.require_time_sheet_entry_flag &&
        require_start_and_end_time_on_time_entry_flag == other.require_start_and_end_time_on_time_entry_flag &&
        allow_in_cell_entry_on_time_sheet == other.allow_in_cell_entry_on_time_sheet &&
        enter_time_against_company_flag == other.enter_time_against_company_flag &&
        allow_expenses_entered_against_companies_flag == other.allow_expenses_entered_against_companies_flag &&
        time_reminder_email_flag == other.time_reminder_email_flag &&
        days_tolerance == other.days_tolerance &&
        minimum_hours == other.minimum_hours &&
        time_sheet_start_date == other.time_sheet_start_date &&
        hire_date == other.hire_date &&
        service_default_location == other.service_default_location &&
        service_default_department == other.service_default_department &&
        service_default_board == other.service_default_board &&
        restrict_service_default_location_flag == other.restrict_service_default_location_flag &&
        restrict_service_default_department_flag == other.restrict_service_default_department_flag &&
        excluded_service_board_ids == other.excluded_service_board_ids &&
        project_default_location == other.project_default_location &&
        project_default_department == other.project_default_department &&
        project_default_board == other.project_default_board &&
        restrict_project_default_location_flag == other.restrict_project_default_location_flag &&
        restrict_project_default_department_flag == other.restrict_project_default_department_flag &&
        excluded_project_board_ids == other.excluded_project_board_ids &&
        schedule_default_location == other.schedule_default_location &&
        schedule_default_department == other.schedule_default_department &&
        schedule_capacity == other.schedule_capacity &&
        service_location == other.service_location &&
        restrict_schedule_flag == other.restrict_schedule_flag &&
        hide_member_in_dispatch_portal_flag == other.hide_member_in_dispatch_portal_flag &&
        calendar == other.calendar &&
        sales_default_location == other.sales_default_location &&
        restrict_default_sales_territory_flag == other.restrict_default_sales_territory_flag &&
        warehouse == other.warehouse &&
        warehouse_bin == other.warehouse_bin &&
        restrict_default_warehouse_flag == other.restrict_default_warehouse_flag &&
        restrict_default_warehouse_bin_flag == other.restrict_default_warehouse_bin_flag &&
        mapi_name == other.mapi_name &&
        calendar_sync_integration_flag == other.calendar_sync_integration_flag &&
        enable_ldap_authentication_flag == other.enable_ldap_authentication_flag &&
        ldap_configuration == other.ldap_configuration &&
        ldap_user_name == other.ldap_user_name &&
        company_activity_tab_format == other.company_activity_tab_format &&
        invoice_time_tab_format == other.invoice_time_tab_format &&
        invoice_screen_default_tab_format == other.invoice_screen_default_tab_format &&
        invoicing_display_options == other.invoicing_display_options &&
        agreement_invoicing_display_options == other.agreement_invoicing_display_options &&
        corelytics_username == other.corelytics_username &&
        corelytics_password == other.corelytics_password &&
        authentication_service_type == other.authentication_service_type &&
        timebased_one_time_password_activated == other.timebased_one_time_password_activated &&
        directional_sync == other.directional_sync &&
        sso_session_flag == other.sso_session_flag &&
        sso_client_id == other.sso_client_id &&
        _info == other._info
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(other)
      self == other
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [id, identifier, password, first_name, middle_initial, last_name, title, report_card, license_class,
       disable_online_flag, enable_mobile_flag, type, employee_identifer, vendor_number, notes, time_zone, country, service_board_team_ids, enable_mobile_gps_flag, inactive_date, inactive_flag, last_login, photo, toast_notification_flag, office_email, office_phone, office_extension, mobile_email, mobile_phone, mobile_extension, home_email, home_phone, home_extension, default_email, default_phone, security_role, admin_flag, structure_level, security_location, default_location, default_department, reports_to, restrict_location_flag, restrict_department_flag, work_role, work_type, time_approver, expense_approver, billable_forecast, daily_capacity, hourly_cost, hourly_rate, include_in_utilization_reporting_flag, require_expense_entry_flag, require_time_sheet_entry_flag, require_start_and_end_time_on_time_entry_flag, allow_in_cell_entry_on_time_sheet, enter_time_against_company_flag, allow_expenses_entered_against_companies_flag, time_reminder_email_flag, days_tolerance, minimum_hours, time_sheet_start_date, hire_date, service_default_location, service_default_department, service_default_board, restrict_service_default_location_flag, restrict_service_default_department_flag, excluded_service_board_ids, project_default_location, project_default_department, project_default_board, restrict_project_default_location_flag, restrict_project_default_department_flag, excluded_project_board_ids, schedule_default_location, schedule_default_department, schedule_capacity, service_location, restrict_schedule_flag, hide_member_in_dispatch_portal_flag, calendar, sales_default_location, restrict_default_sales_territory_flag, warehouse, warehouse_bin, restrict_default_warehouse_flag, restrict_default_warehouse_bin_flag, mapi_name, calendar_sync_integration_flag, enable_ldap_authentication_flag, ldap_configuration, ldap_user_name, company_activity_tab_format, invoice_time_tab_format, invoice_screen_default_tab_format, invoicing_display_options, agreement_invoicing_display_options, corelytics_username, corelytics_password, authentication_service_type, timebased_one_time_password_activated, directional_sync, sso_session_flag, sso_client_id, _info].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      attributes = attributes.transform_keys(&:to_sym)
      transformed_hash = {}
      openapi_types.each_pair do |key, type|
        if attributes.key?(attribute_map[key]) && attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = nil
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[attribute_map[key]].is_a?(Array)
            transformed_hash["#{key}"] = attributes[attribute_map[key]].map do |v|
              _deserialize(::Regexp.last_match(1), v)
            end
          end
        elsif !attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = _deserialize(type, attributes[attribute_map[key]])
        end
      end
      new(transformed_hash)
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def self._deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = ConnectWise.const_get(type)
        klass.respond_to?(:openapi_any_of) || klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
